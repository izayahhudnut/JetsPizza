"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// rsc/utils.tsx\n\n\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nvar isFunction = (x)=>typeof x === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTJEOztBQ0FwRCxJQUFNRyx3QkFBd0JDLE9BQU9DLEdBQUEsQ0FBSTtBQUN6QyxJQUFNQyxzQ0FBc0MsS0FBSzs7QURHeEQsU0FBU0MsMEJBQTBCQyxLQUFBO0lBQ2pDLE9BQU8sQ0FBQyxDQUNOQSxDQUFBQSxTQUNBLE9BQU9BLFVBQVUsWUFDakIsVUFBVUEsU0FDVkEsTUFBTUMsSUFBQSxLQUFTTixxQkFBQTtBQUVuQjtBQUVBLFNBQVNPLHNCQUNQRixLQUFBO0lBRUEsSUFBSSxDQUFDRCwwQkFBMEJDLFFBQVE7UUFDckMsTUFBTSxJQUFJRyxNQUNSO0lBRUo7QUFDRjtBQUVBLFNBQVNDLGtCQUFrQkosS0FBQTtJQUN6QixNQUFNSyxlQUFlTiwwQkFBMEJDO0lBRS9DLElBQUksQ0FBQ0ssZ0JBQWdCLE9BQU9MLFVBQVUsYUFBYTtRQUNqRCxNQUFNLElBQUlHLE1BQ1I7SUFFSjtJQUVBLE9BQU9FO0FBQ1Q7QUFnQ08sU0FBU0Msb0JBQ2RDLGVBQUE7SUFFQUwsc0JBQXNCSztJQUV0QixPQUFPO1FBQ0wsQ0FBQ1gsT0FBT1ksYUFBYTtZQUNuQixJQUFJQyxNQUNGRjtZQUNGLElBQUlHLE9BQU9ELElBQUlDLElBQUE7WUFDZixJQUFJQyxPQUFPO1lBQ1gsSUFBSUMsVUFBVTtZQUVkLE9BQU87Z0JBQ0wsTUFBTUM7b0JBQ0osSUFBSUYsTUFBTSxPQUFPO3dCQUFFWCxPQUFPVTt3QkFBTUMsTUFBTTtvQkFBSztvQkFFM0NGLE1BQU0sTUFBTUE7b0JBRVosSUFBSSxPQUFPQSxJQUFJSyxLQUFBLEtBQVUsYUFBYTt3QkFDcEMsTUFBTUwsSUFBSUssS0FBQTtvQkFDWjtvQkFDQSxJQUFJLFVBQVVMLE9BQU9BLElBQUlNLElBQUEsRUFBTTt3QkFDN0IsSUFBSU4sSUFBSU0sSUFBQSxFQUFNOzRCQUNaLE9BQVFOLElBQUlNLElBQUEs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QUFBLENBQ25CLE9BQU82QixRQUFRLGNBQ1hXLEtBQUEsQ0FBTSxFQUFDLEdBQ1AsQ0FBQ1E7UUFDQyxJQUFJbkQsV0FBV21ELFdBQVc7WUFDeEIsT0FBT1IsS0FBQSxDQUFNLEVBQUMsQ0FBRSxDQUFBUztnQkFDZCxPQUFPO29CQUFFLEdBQUdBLENBQUE7b0JBQUcsQ0FBQ3BCLElBQUcsRUFBR21CLFNBQVNDLENBQUEsQ0FBRXBCLElBQUk7Z0JBQUU7WUFDekM7UUFDRixPQUFPO1lBQ0wsT0FBT1csS0FBQSxDQUFNLEVBQUMsQ0FBRTtnQkFBRSxHQUFHQSxLQUFBLENBQU0sRUFBQztnQkFBRyxDQUFDWCxJQUFHLEVBQUdtQjtZQUFTO1FBQ2pEO0lBQ0YsR0FDSjtRQUFDbkI7S0FBRztJQUdOLElBQUlFLEtBQUtjLE1BQUEsS0FBVyxHQUFHO1FBQ3JCLE9BQU9MO0lBQ1QsT0FBTztRQUNMLE9BQU87WUFBQ0EsS0FBQSxDQUFNLEVBQUMsQ0FBRVQsSUFBQSxDQUFLLEVBQUU7WUFBR2U7U0FBTTtJQUNuQztBQUNGO0FBRU8sU0FBU0k7SUFHZCxNQUFNQyxVQUFnQm5ELDZDQUFBLENBQWNHO0lBQ3BDLE9BQU9nRDtBQUNUO0FBRU8sU0FBU0M7SUFDZCxNQUFNQyxjQUFvQnJELDZDQUFBLENBQ3hCSTtJQUdGLElBQUlpRCxnQkFBZ0IsTUFBTTtRQUN4QixNQUFNLElBQUkxRixNQUFNO0lBQ2xCO0lBRUEsT0FBTzBGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zaGFyZWQtY2xpZW50L3N0cmVhbWFibGUudHN4P2UxOGIiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vY29uc3RhbnRzLnRzP2FiNzIiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc2hhcmVkLWNsaWVudC9jb250ZXh0LnRzeD9jYjNmIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3V0aWxzLnRzeD83YTJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgdHlwZSB7IFN0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZnVuY3Rpb24gaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIHJldHVybiAhIShcbiAgICB2YWx1ZSAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAndHlwZScgaW4gdmFsdWUgJiZcbiAgICB2YWx1ZS50eXBlID09PSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEVcbiAgKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3RyZWFtYWJsZVZhbHVlKFxuICB2YWx1ZTogdW5rbm93bixcbik6IGFzc2VydHMgdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgaWYgKCFoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZhbHVlOiB0aGlzIGhvb2sgb25seSBhY2NlcHRzIHZhbHVlcyBjcmVhdGVkIHZpYSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlYC4nLFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJlYW1hYmxlVmFsdWUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICBjb25zdCBoYXNTaWduYXR1cmUgPSBoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlKHZhbHVlKTtcblxuICBpZiAoIWhhc1NpZ25hdHVyZSAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLicsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBoYXNTaWduYXR1cmU7XG59XG5cbi8qKlxuICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRha2VzIGEgc3RyZWFtYWJsZSB2YWx1ZSBjcmVhdGVkIHZpYSB0aGUgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpLnZhbHVlYCBBUEksXG4gKiBhbmQgcmV0dXJucyBhbiBhc3luYyBpdGVyYXRvci5cbiAqXG4gKiBgYGBqc1xuICogLy8gSW5zaWRlIHlvdXIgQUkgYWN0aW9uOlxuICpcbiAqIGFzeW5jIGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAqICAgJ3VzZSBzZXJ2ZXInXG4gKiAgIGNvbnN0IHN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKTtcbiAqXG4gKiAgIHN0cmVhbWFibGUudXBkYXRlKDEpO1xuICogICBzdHJlYW1hYmxlLnVwZGF0ZSgyKTtcbiAqICAgc3RyZWFtYWJsZS5kb25lKDMpO1xuICogICAvLyAuLi5cbiAqICAgcmV0dXJuIHN0cmVhbWFibGUudmFsdWU7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBBbmQgdG8gcmVhZCB0aGUgdmFsdWU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IHN0cmVhbWFibGVWYWx1ZSA9IGF3YWl0IGFjdGlvbigpXG4gKiBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgcmVhZFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSB7XG4gKiAgIGNvbnNvbGUubG9nKHYpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGxvZ3Mgb3V0IDEsIDIsIDMgb24gY29uc29sZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRTdHJlYW1hYmxlVmFsdWU8VCA9IHVua25vd24+KFxuICBzdHJlYW1hYmxlVmFsdWU6IFN0cmVhbWFibGVWYWx1ZTxUPixcbik6IEFzeW5jSXRlcmFibGU8VCB8IHVuZGVmaW5lZD4ge1xuICBhc3NlcnRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBsZXQgcm93OiBTdHJlYW1hYmxlVmFsdWU8VD4gfCBQcm9taXNlPFN0cmVhbWFibGVWYWx1ZTxUPj4gPVxuICAgICAgICBzdHJlYW1hYmxlVmFsdWU7XG4gICAgICBsZXQgY3VyciA9IHJvdy5jdXJyO1xuICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgIGxldCBpbml0aWFsID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIHsgdmFsdWU6IGN1cnIsIGRvbmU6IHRydWUgfTtcblxuICAgICAgICAgIHJvdyA9IGF3YWl0IHJvdztcblxuICAgICAgICAgIGlmICh0eXBlb2Ygcm93LmVycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgcm93LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2N1cnInIGluIHJvdyB8fCByb3cuZGlmZikge1xuICAgICAgICAgICAgaWYgKHJvdy5kaWZmKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocm93LmRpZmZbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBwYXRjaDogY2FuIG9ubHkgYXBwZW5kIHRvIHN0cmluZyB0eXBlcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgQUkgU0RLLicsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoY3VyciBhcyBzdHJpbmcpID0gY3VyciArIHJvdy5kaWZmWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnIgPSByb3cuY3VycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZW1pdHRlZCB7IGRvbmU6IHRydWUgfSB3b24ndCBiZSB1c2VkIGFzIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGZvciBhd2FpdC4uLm9mIHN5bnRheC5cbiAgICAgICAgICAgIGlmICghcm93Lm5leHQpIHtcbiAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyb3cubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyA9IHJvdy5uZXh0O1xuICAgICAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgY2h1bmsgYW5kIHRoZXJlIGlzbid0IGFuIGluaXRpYWwgdmFsdWUgeWV0LlxuICAgICAgICAgICAgICAvLyBMZXQncyBza2lwIHRoaXMgb25lLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBgdXNlU3RyZWFtYWJsZVZhbHVlYCBpcyBhIFJlYWN0IGhvb2sgdGhhdCB0YWtlcyBhIHN0cmVhbWFibGUgdmFsdWUgY3JlYXRlZCB2aWEgdGhlIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKS52YWx1ZWAgQVBJLFxuICogYW5kIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUsIGVycm9yLCBhbmQgcGVuZGluZyBzdGF0ZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29uc3VtaW5nIHN0cmVhbWFibGUgdmFsdWVzIHJlY2VpdmVkIGZyb20gYSBjb21wb25lbnQncyBwcm9wcy4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KHsgc3RyZWFtYWJsZVZhbHVlIH0pIHtcbiAqICAgY29uc3QgW2RhdGEsIGVycm9yLCBwZW5kaW5nXSA9IHVzZVN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICpcbiAqICAgaWYgKHBlbmRpbmcpIHJldHVybiA8ZGl2PkxvYWRpbmcuLi48L2Rpdj47XG4gKiAgIGlmIChlcnJvcikgcmV0dXJuIDxkaXY+RXJyb3I6IHtlcnJvci5tZXNzYWdlfTwvZGl2PjtcbiAqXG4gKiAgIHJldHVybiA8ZGl2PkRhdGE6IHtkYXRhfTwvZGl2PjtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RyZWFtYWJsZVZhbHVlPFQgPSB1bmtub3duLCBFcnJvciA9IHVua25vd24+KFxuICBzdHJlYW1hYmxlVmFsdWU/OiBTdHJlYW1hYmxlVmFsdWU8VD4sXG4pOiBbZGF0YTogVCB8IHVuZGVmaW5lZCwgZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkLCBwZW5kaW5nOiBib29sZWFuXSB7XG4gIGNvbnN0IFtjdXJyLCBzZXRDdXJyXSA9IHVzZVN0YXRlPFQgfCB1bmRlZmluZWQ+KFxuICAgIGlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyBzdHJlYW1hYmxlVmFsdWUuY3VyciA6IHVuZGVmaW5lZCxcbiAgKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxFcnJvciB8IHVuZGVmaW5lZD4oXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5lcnJvciA6IHVuZGVmaW5lZCxcbiAgKTtcbiAgY29uc3QgW3BlbmRpbmcsIHNldFBlbmRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/ICEhc3RyZWFtYWJsZVZhbHVlLm5leHQgOiBmYWxzZSxcbiAgKTtcblxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkgcmV0dXJuO1xuXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG4gICAgaWYgKHN0cmVhbWFibGVWYWx1ZS5uZXh0KSB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHNldFBlbmRpbmcodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0Q3Vycih2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzZXRFcnJvcihlIGFzIEVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW3N0cmVhbWFibGVWYWx1ZV0pO1xuXG4gIHJldHVybiBbY3VyciwgZXJyb3IsIHBlbmRpbmddO1xufVxuIiwiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcbmV4cG9ydCBjb25zdCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSA9IDE1ICogMTAwMDtcbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xuJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgdHlwZSB7XG4gIEludGVybmFsQUlQcm92aWRlclByb3BzLFxuICBBSVByb3ZpZGVyLFxuICBJbmZlckFJU3RhdGUsXG4gIFZhbHVlT3JVcGRhdGVyLFxuICBJbmZlckFjdGlvbnMsXG4gIEluZmVyVUlTdGF0ZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHVuZGVmaW5lZCB8IGFueT4odW5kZWZpbmVkKTtcbmNvbnN0IEludGVybmFsQWN0aW9uUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEludGVybmFsQUlQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBpbml0aWFsVUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlUGF0Y2gsXG4gIHdyYXBwZWRBY3Rpb25zLFxuICB3cmFwcGVkU3luY1VJU3RhdGUsXG59OiBJbnRlcm5hbEFJUHJvdmlkZXJQcm9wcykge1xuICBpZiAoISgndXNlJyBpbiBSZWFjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJlYWN0IHZlcnNpb24uJyk7XG4gIH1cblxuICBjb25zdCB1aVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbFVJU3RhdGUpO1xuICBjb25zdCBzZXRVSVN0YXRlID0gdWlTdGF0ZVsxXTtcblxuICBjb25zdCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2ggPSBpbml0aWFsQUlTdGF0ZVBhdGNoXG4gICAgPyAoUmVhY3QgYXMgYW55KS51c2UoaW5pdGlhbEFJU3RhdGVQYXRjaClcbiAgICA6IHVuZGVmaW5lZDtcbiAgaW5pdGlhbEFJU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoKSB7XG4gICAgICByZXR1cm4ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShpbml0aWFsQUlTdGF0ZSksXG4gICAgICAgIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpbml0aWFsQUlTdGF0ZTtcbiAgfSwgW2luaXRpYWxBSVN0YXRlLCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2hdKTtcblxuICBjb25zdCBhaVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbEFJU3RhdGUpO1xuICBjb25zdCBzZXRBSVN0YXRlID0gYWlTdGF0ZVsxXTtcbiAgY29uc3QgYWlTdGF0ZVJlZiA9IFJlYWN0LnVzZVJlZihhaVN0YXRlWzBdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFpU3RhdGVSZWYuY3VycmVudCA9IGFpU3RhdGVbMF07XG4gIH0sIFthaVN0YXRlWzBdXSk7XG5cbiAgY29uc3QgY2xpZW50V3JhcHBlZEFjdGlvbnMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHdyYXBwZWRBY3Rpb25zKS5tYXAoKFtrZXksIGFjdGlvbl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXN5bmMgKC4uLmFyZ3M6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgcmVzdWx0XSA9IGF3YWl0IGFjdGlvbihcbiAgICAgICAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgICAgICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFpU3RhdGVbMV0oXG4gICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICBdKSxcbiAgICAgICksXG4gICAgW3dyYXBwZWRBY3Rpb25zXSxcbiAgKTtcblxuICBjb25zdCBjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCB1aVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZSEoXG4gICAgICAgIGFpU3RhdGVTbmFwc2hvdCxcbiAgICAgICk7XG5cbiAgICAgIGlmICh1aVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VUlTdGF0ZSh1aVN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXRjaGVkQWlTdGF0ZSA9IGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICApO1xuICAgICAgICBzZXRBSVN0YXRlKHBhdGNoZWRBaVN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbd3JhcHBlZFN5bmNVSVN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8SW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e2FpU3RhdGV9PlxuICAgICAgPEludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXt1aVN0YXRlfT5cbiAgICAgICAgPEludGVybmFsQWN0aW9uUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e2NsaWVudFdyYXBwZWRBY3Rpb25zfT5cbiAgICAgICAgICA8SW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyXG4gICAgICAgICAgICB2YWx1ZT17Y2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9ufVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L0ludGVybmFsU3luY1VJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgICAgICAgPC9JbnRlcm5hbEFjdGlvblByb3ZpZGVyLlByb3ZpZGVyPlxuICAgICAgPC9JbnRlcm5hbFVJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgICA8L0ludGVybmFsQUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCkge1xuICB0eXBlIFQgPSBJbmZlclVJU3RhdGU8QUksIGFueT47XG5cbiAgY29uc3Qgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PFxuICAgIFtULCAodjogVCB8ICgodl86IFQpID0+IFQpKSA9PiB2b2lkXSB8IG51bGwgfCB1bmRlZmluZWRcbiAgPihJbnRlcm5hbFVJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZVVJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgaWYgKHN0YXRlWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGluaXRpYWxVSVN0YXRlYCBtdXN0IGJlIHByb3ZpZGVkIHRvIGBjcmVhdGVBSWAgb3IgYDxBST5gJyxcbiAgICApO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLy8gVE9ETzogSG93IGRvIHdlIGF2b2lkIGNhdXNpbmcgYSByZS1yZW5kZXIgd2hlbiB0aGUgQUkgc3RhdGUgY2hhbmdlcyBidXQgeW91XG4vLyBhcmUgb25seSBsaXN0ZW5pbmcgdG8gYSBzcGVjaWZpYyBrZXk/IFdlIG5lZWQgdXNlU0VTIHBlcmhhcHM/XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogW1xuICBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4gIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8SW5mZXJBSVN0YXRlPEFJLCBhbnk+PikgPT4gdm9pZCxcbl07XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogW1xuICBJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0sXG4gIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPikgPT4gdm9pZCxcbl07XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICB0eXBlIFQgPSBJbmZlckFJU3RhdGU8QUksIGFueT47XG5cbiAgY29uc3Qgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PFxuICAgIFtULCAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPFQ+KSA9PiB2b2lkXSB8IG51bGwgfCB1bmRlZmluZWRcbiAgPihJbnRlcm5hbEFJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZUFJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgaWYgKHN0YXRlWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGluaXRpYWxBSVN0YXRlYCBtdXN0IGJlIHByb3ZpZGVkIHRvIGBjcmVhdGVBSWAgb3IgYDxBST5gJyxcbiAgICApO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBzdGF0ZVswXSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnV2hlbiB1c2luZyBgdXNlQUlTdGF0ZWAgd2l0aCBhIGtleSwgdGhlIEFJIHN0YXRlIG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gIGNvbnN0IHNldHRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnXG4gICAgICA/IHN0YXRlWzFdXG4gICAgICA6IChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8VD4pID0+IHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVsxXShzID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucywgW2tleV06IG5ld1N0YXRlKHNba2V5XSkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVbMV0oeyAuLi5zdGF0ZVswXSwgW2tleV06IG5ld1N0YXRlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBba2V5XSxcbiAgKTtcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtzdGF0ZVswXVthcmdzWzBdXSwgc2V0dGVyXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aW9uczxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCkge1xuICB0eXBlIFQgPSBJbmZlckFjdGlvbnM8QUksIGFueT47XG5cbiAgY29uc3QgYWN0aW9ucyA9IFJlYWN0LnVzZUNvbnRleHQ8VD4oSW50ZXJuYWxBY3Rpb25Qcm92aWRlcik7XG4gIHJldHVybiBhY3Rpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY1VJU3RhdGUoKSB7XG4gIGNvbnN0IHN5bmNVSVN0YXRlID0gUmVhY3QudXNlQ29udGV4dDwoKSA9PiBQcm9taXNlPHZvaWQ+PihcbiAgICBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIsXG4gICk7XG5cbiAgaWYgKHN5bmNVSVN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlU3luY1VJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuXG4gIHJldHVybiBzeW5jVUlTdGF0ZTtcbn1cblxuZXhwb3J0IHsgdXNlQUlTdGF0ZSB9O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8VCA9IGFueT4oKSB7XG4gIGxldCByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWQsIHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZSEsXG4gICAgcmVqZWN0OiByZWplY3QhLFxuICB9O1xufVxuXG4vLyBVc2UgdGhlIG5hbWUgYFJgIGZvciBgUm93YCBhcyBpdCB3aWxsIGJlIHNob3J0ZXIgaW4gdGhlIFJTQyBwYXlsb2FkLlxuY29uc3QgUiA9IFtcbiAgKGFzeW5jICh7XG4gICAgYywgLy8gY3VycmVudFxuICAgIG4sIC8vIG5leHRcbiAgfToge1xuICAgIGM6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBuOiBQcm9taXNlPGFueT47XG4gIH0pID0+IHtcbiAgICBjb25zdCBjaHVuayA9IGF3YWl0IG47XG4gICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsuYXBwZW5kKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIHtjfVxuICAgICAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICAgICAgPC9TdXNwZW5zZT5cbiAgICAgICAgPC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICk7XG4gIH0pIGFzIHVua25vd24gYXMgUmVhY3QuRkM8e1xuICAgIGM6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBuOiBQcm9taXNlPGFueT47XG4gIH0+LFxuXVswXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlZENodW5rKGluaXRpYWxWYWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuXG4gIHJldHVybiB7XG4gICAgcm93OiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2luaXRpYWxWYWx1ZX0+XG4gICAgICAgIDxSIGM9e2luaXRpYWxWYWx1ZX0gbj17cHJvbWlzZX0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAoeDogdW5rbm93bik6IHggaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBjb25zdW1lU3RyZWFtID0gYXN5bmMgKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pID0+IHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsic3RhcnRUcmFuc2l0aW9uIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlU3RhdGUiLCJTVFJFQU1BQkxFX1ZBTFVFX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSIsImhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUiLCJ2YWx1ZSIsInR5cGUiLCJhc3NlcnRTdHJlYW1hYmxlVmFsdWUiLCJFcnJvciIsImlzU3RyZWFtYWJsZVZhbHVlIiwiaGFzU2lnbmF0dXJlIiwicmVhZFN0cmVhbWFibGVWYWx1ZSIsInN0cmVhbWFibGVWYWx1ZSIsImFzeW5jSXRlcmF0b3IiLCJyb3ciLCJjdXJyIiwiZG9uZSIsImluaXRpYWwiLCJuZXh0IiwiZXJyb3IiLCJkaWZmIiwidXNlU3RyZWFtYWJsZVZhbHVlIiwic2V0Q3VyciIsInNldEVycm9yIiwicGVuZGluZyIsInNldFBlbmRpbmciLCJjYW5jZWxsZWQiLCJpdGVyYXRvciIsImUiLCJSZWFjdCIsImpzb25kaWZmcGF0Y2giLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsIlIiLCJjIiwibiIsImNodW5rIiwiYXBwZW5kIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsImlzRnVuY3Rpb24iLCJ4IiwiSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIiLCJSZWFjdDIiLCJjcmVhdGVDb250ZXh0IiwiSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIiLCJJbnRlcm5hbEFjdGlvblByb3ZpZGVyIiwiSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyIiwiSW50ZXJuYWxBSVByb3ZpZGVyIiwiaW5pdGlhbFVJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlUGF0Y2giLCJ3cmFwcGVkQWN0aW9ucyIsIndyYXBwZWRTeW5jVUlTdGF0ZSIsInVpU3RhdGUiLCJzZXRVSVN0YXRlIiwicmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoIiwidXNlIiwidXNlTWVtbyIsInBhdGNoIiwiY2xvbmUiLCJhaVN0YXRlIiwic2V0QUlTdGF0ZSIsImFpU3RhdGVSZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiY2xpZW50V3JhcHBlZEFjdGlvbnMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJrZXkiLCJhY3Rpb24iLCJhcmdzIiwiYWlTdGF0ZVNuYXBzaG90IiwiYWlTdGF0ZURlbHRhIiwicmVzdWx0IiwiZGVsdGEiLCJjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24iLCJwYXRjaGVkQWlTdGF0ZSIsIlByb3ZpZGVyIiwidXNlVUlTdGF0ZSIsInN0YXRlIiwidXNlQ29udGV4dCIsIkFycmF5IiwiaXNBcnJheSIsInVzZUFJU3RhdGUiLCJsZW5ndGgiLCJzZXR0ZXIiLCJ1c2VDYWxsYmFjayIsIm5ld1N0YXRlIiwicyIsInVzZUFjdGlvbnMiLCJhY3Rpb25zIiwidXNlU3luY1VJU3RhdGUiLCJzeW5jVUlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_3___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"9b1b81da54555e525e61b710769579b749345d1f\":\"$$ACTION_0\"} */ \n\n\n\n// rsc/utils.tsx\n\n\nfunction createResolvablePromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspensedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\nvar isFunction = (x)=>typeof x === \"function\";\nvar consumeStream = async (stream)=>{\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n};\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/streamable.tsx\n\n// core/util/retry-with-exponential-backoff.ts\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded image.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    switch(prompt.type){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>{\n                    switch(message.role){\n                        case \"system\":\n                            {\n                                return {\n                                    role: \"system\",\n                                    content: message.content\n                                };\n                            }\n                        case \"user\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"user\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"user\",\n                                    content: message.content.map((part)=>{\n                                        var _a;\n                                        switch(part.type){\n                                            case \"text\":\n                                                {\n                                                    return part;\n                                                }\n                                            case \"image\":\n                                                {\n                                                    if (part.image instanceof URL) {\n                                                        return {\n                                                            type: \"image\",\n                                                            image: part.image,\n                                                            mimeType: part.mimeType\n                                                        };\n                                                    }\n                                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                                    return {\n                                                        type: \"image\",\n                                                        image: imageUint8,\n                                                        mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                                                    };\n                                                }\n                                        }\n                                    })\n                                };\n                            }\n                        case \"assistant\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"assistant\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"assistant\",\n                                    content: message.content\n                                };\n                            }\n                        case \"tool\":\n                            {\n                                return message;\n                            }\n                    }\n                }));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = prompt;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n    return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zodSchema);\n}\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallsStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"9\",\n    name: \"tool_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n            throw new Error('\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.');\n        }\n        return {\n            type: \"tool_call\",\n            value\n        };\n    }\n};\nvar toolResultStreamPart = {\n    code: \"a\",\n    name: \"tool_result\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\" || !(\"result\" in value)) {\n            throw new Error('\"tool_result\" parts expect an object with a \"toolCallId\", \"toolName\", \"args\", and \"result\" property.');\n        }\n        return {\n            type: \"tool_result\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallsStreamPart,\n    messageAnnotationsStreamPart,\n    toolCallStreamPart,\n    toolResultStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallsStreamPart.code]: toolCallsStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [toolResultStreamPart.code]: toolResultStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [toolResultStreamPart.name]: toolResultStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_9__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/streamable.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspensedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    const streamable2 = {\n        /**\n     * The value of the streamable UI. This can be returned from a Server Action and received by the client.\n     */ value: row,\n        /**\n     * This method updates the current UI node. It takes a new UI node and replaces the old one.\n     */ update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return streamable2;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        /**\n     * This method is used to append a new UI node to the end of the old one.\n     * Once appended a new UI node, the previous UI node cannot be updated anymore.\n     *\n     * @example\n     * ```jsx\n     * const ui = createStreamableUI(<div>hello</div>)\n     * ui.append(<div>world</div>)\n     *\n     * // The UI node will be:\n     * // <>\n     * //   <div>hello</div>\n     * //   <div>world</div>\n     * // </>\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        /**\n     * This method is used to signal that there is an error in the UI stream.\n     * It will be thrown on the client side and caught by the nearest error boundary component.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n            return streamable2;\n        },\n        /**\n     * This method marks the UI node as finalized. You can either call it without any parameters or with a new UI node as the final state.\n     * Once called, the UI node cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return streamable2;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable2 = {\n        /**\n     * @internal This is an internal lock to prevent the value from being\n     * updated by the user.\n     */ set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        /**\n     * The value of the streamable. This can be returned from a Server Action and\n     * received by the client. To read the streamed values, use the\n     * `readStreamableValue` or `useStreamableValue` APIs.\n     */ get value () {\n            return createWrapped(true);\n        },\n        /**\n     * This method updates the current value with a new one.\n     */ update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        /**\n     * This method is used to append a delta string to the current value. It\n     * requires the current value of the streamable to be a string.\n     *\n     * @example\n     * ```jsx\n     * const streamable = createStreamableValue('hello');\n     * streamable.append(' world');\n     *\n     * // The value will be 'hello world'\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        /**\n     * This method is used to signal that there is an error in the value stream.\n     * It will be thrown on the client side when consumed via\n     * `readStreamableValue` or `useStreamableValue`.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable2;\n        },\n        /**\n     * This method marks the value as finalized. You can either call it without\n     * any parameters or with a new value as the final state.\n     * Once called, the value cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response\n     * will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable2;\n            }\n            resolvable.resolve({});\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name, { description, parameters }])=>{\n        return {\n            name,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a = options.functions) == null ? void 0 : _a[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a = options.tools) == null ? void 0 : _a[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, system, prompt, messages, maxRetries, abortSignal, initial, text, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(...args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool])=>({\n                        type: \"function\",\n                        name,\n                        description: tool.description,\n                        parameters: convertZodToJSONSchema(tool.parameters)\n                    }))\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: convertToLanguageModelPrompt(validatedPrompt),\n            abortSignal\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            handleRender([\n                                {\n                                    content,\n                                    done: false,\n                                    delta: value.textDelta\n                                }\n                            ], textRender, ui);\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            handleRender([\n                                parseResult.value,\n                                {\n                                    toolName,\n                                    toolCallId: value.toolCallId\n                                }\n                            ], tool.generate, ui);\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {}\n                }\n            }\n            if (hasToolCall) {\n                await finished;\n                ui.done();\n            } else {\n                handleRender([\n                    {\n                        content,\n                        done: true\n                    }\n                ], textRender, ui);\n                await finished;\n                ui.done();\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"9b1b81da54555e525e61b710769579b749345d1f\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_3__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNlcnZlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDSDs7QUNEQztBQStCeEI7QUE3QkQsU0FBU007SUFDZCxJQUFJQyxTQUE2QkM7SUFDakMsTUFBTUMsVUFBVSxJQUFJQyxRQUFXLENBQUNDLEtBQUtDO1FBQ25DTCxVQUFVSTtRQUNWSCxTQUFTSTtJQUNYO0lBQ0EsT0FBTztRQUNMSDtRQUNBRjtRQUNBQztJQUNGO0FBQ0Y7QUFHQSxJQUFNSyxJQUFJO0lBQ1AsT0FBTyxFQUNOQyxDQUFBO0lBQ0FDLENBQUEsRUFDRjtRQUlFLE1BQU1DLFFBQVEsTUFBTUQ7UUFDcEIsSUFBSUMsTUFBTUMsSUFBQSxFQUFNO1lBQ2QsT0FBT0QsTUFBTUUsS0FBQTtRQUNmO1FBRUEsSUFBSUYsTUFBTUcsTUFBQSxFQUFRO1lBQ2hCLE9BQ0UsZ0JBQUFkLHVEQUFBQSxDQUFBRix1REFBQUEsRUFBQTtnQkFDR2lCLFVBQUE7b0JBQUFOO29CQUNELGdCQUFBVixzREFBQUEsQ0FBQ0YsMkNBQVFBLEVBQVI7d0JBQVNtQixVQUFVTCxNQUFNRSxLQUFBO3dCQUN4QkUsVUFBQSxnQkFBQWhCLHNEQUFBQSxDQUFDUyxHQUFBOzRCQUFFQyxHQUFHRSxNQUFNRSxLQUFBOzRCQUFPSCxHQUFHQyxNQUFNTSxJQUFBO3dCQUFBO29CQUFNO2lCQUNwQztZQUFBO1FBR047UUFFQSxPQUNFLGdCQUFBbEIsc0RBQUFBLENBQUNGLDJDQUFRQSxFQUFSO1lBQVNtQixVQUFVTCxNQUFNRSxLQUFBO1lBQ3hCRSxVQUFBLGdCQUFBaEIsc0RBQUFBLENBQUNTLEdBQUE7Z0JBQUVDLEdBQUdFLE1BQU1FLEtBQUE7Z0JBQU9ILEdBQUdDLE1BQU1NLElBQUE7WUFBQTtRQUFNO0lBR3hDO0NBSUYsQ0FBRSxFQUFDO0FBRUksU0FBU0MscUJBQXFCQyxZQUFBO0lBQ25DLE1BQU0sRUFBRWYsT0FBQSxF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cGFjazovL2Zyb250ZW5kLy4uL3V0aWxzLnRzeD83YTJlIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3N0cmVhbWFibGUudHN4PzY5MWYiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vY29yZS91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50cz9mMGQwIiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL2NvcmUvdXRpbC9kZWxheS50cz9hMWU3Iiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL2NvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHM/OTU0NSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9jb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHM/ZTkyZiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9jb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50cz83MTc0Iiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL2NvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzPzU3OGUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzP2Q1OGMiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vY29yZS91dGlsL2NvbnZlcnQtem9kLXRvLWpzb24tc2NoZW1hLnRzPzAwZmYiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vc2hhcmVkL3N0cmVhbS1wYXJ0cy50cz9jNGE4Iiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NoYXJlZC91dGlscy50cz9mOGNmIiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3N0cmVhbXMvYWktc3RyZWFtLnRzPzQ4NTQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vc3RyZWFtcy9zdHJlYW0tZGF0YS50cz82NzMwIiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3N0cmVhbXMvb3BlbmFpLXN0cmVhbS50cz9iMmJkIiwid2VicGFjazovL2Zyb250ZW5kLy4uL2NvbnN0YW50cy50cz9hYjcyIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3N0cmVhbS11aS9zdHJlYW0tdWkudHN4PzFjY2EiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vcHJvdmlkZXIudHN4PzMwZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICdhc3luY19ob29rcyc7XG5pbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gJ2pzb25kaWZmcGF0Y2gnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UsIGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB0eXBlIHtcbiAgQUlQcm92aWRlcixcbiAgSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4gIEluZmVyQUlTdGF0ZSxcbiAgTXV0YWJsZUFJU3RhdGUsXG4gIFZhbHVlT3JVcGRhdGVyLFxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gSXQgaXMgcG9zc2libGUgdGhhdCBtdWx0aXBsZSBBSSByZXF1ZXN0cyBnZXQgaW4gY29uY3VycmVudGx5LCBmb3IgZGlmZmVyZW50XG4vLyBBSSBpbnN0YW5jZXMuIFNvIEFMUyBpcyBuZWNlc3NhcnkgaGVyZSBmb3IgYSBzaW1wbGVyIEFQSS5cbmNvbnN0IGFzeW5jQUlTdGF0ZVN0b3JhZ2UgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2U8e1xuICBjdXJyZW50U3RhdGU6IGFueTtcbiAgb3JpZ2luYWxTdGF0ZTogYW55O1xuICBzZWFsZWQ6IGJvb2xlYW47XG4gIG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zO1xuICBtdXRhdGlvbkRlbHRhUHJvbWlzZT86IFByb21pc2U8YW55PjtcbiAgbXV0YXRpb25EZWx0YVJlc29sdmU/OiAodjogYW55KSA9PiB2b2lkO1xufT4oKTtcblxuZnVuY3Rpb24gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RvcmUgPSBhc3luY0FJU3RhdGVTdG9yYWdlLmdldFN0b3JlKCk7XG4gIGlmICghc3RvcmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aEFJU3RhdGU8UywgVD4oXG4gIHsgc3RhdGUsIG9wdGlvbnMgfTogeyBzdGF0ZTogUzsgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMgfSxcbiAgZm46ICgpID0+IFQsXG4pOiBUIHtcbiAgcmV0dXJuIGFzeW5jQUlTdGF0ZVN0b3JhZ2UucnVuKFxuICAgIHtcbiAgICAgIGN1cnJlbnRTdGF0ZTogc3RhdGUsXG4gICAgICBvcmlnaW5hbFN0YXRlOiBzdGF0ZSxcbiAgICAgIHNlYWxlZDogZmFsc2UsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgZm4sXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBSVN0YXRlRGVsdGFQcm9taXNlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coJ0ludGVybmFsIGVycm9yIG9jY3VycmVkLicpO1xuICByZXR1cm4gc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2U7XG59XG5cbi8vIEludGVybmFsIG1ldGhvZC4gVGhpcyB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgQUkgQWN0aW9uIGhhcyBiZWVuIHJldHVybmVkXG4vLyBhbmQgeW91IGNhbiBubyBsb25nZXIgY2FsbCBgZ2V0TXV0YWJsZUFJU3RhdGUoKWAgaW5zaWRlIGFueSBhc3luYyBjYWxsYmFja3Ncbi8vIGNyZWF0ZWQgYnkgdGhhdCBBY3Rpb24uXG5leHBvcnQgZnVuY3Rpb24gc2VhbE11dGFibGVBSVN0YXRlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coJ0ludGVybmFsIGVycm9yIG9jY3VycmVkLicpO1xuICBzdG9yZS5zZWFsZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBBSSBzdGF0ZS5cbiAqIElmIGBrZXlgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkgaW4gdGhlXG4gKiBBSSBzdGF0ZSwgaWYgaXQncyBhbiBvYmplY3QuIElmIGl0J3Mgbm90IGFuIG9iamVjdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZSBjb25zdCBzdGF0ZSA9IGdldEFJU3RhdGUoKSAvLyBHZXQgdGhlIGVudGlyZSBBSSBzdGF0ZVxuICogQGV4YW1wbGUgY29uc3QgZmllbGQgPSBnZXRBSVN0YXRlKCdrZXknKSAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBrZXlcbiAqL1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV07XG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldEFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uJyxcbiAgKTtcblxuICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAga2V5LFxuICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleSBhcyBrZXlvZiB0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlXTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtdXRhYmxlIEFJIHN0YXRlLiBOb3RlIHRoYXQgeW91IG11c3QgY2FsbCBgLmNsb3NlKClgIHdoZW4gZmluaXNoaW5nXG4gKiB1cGRhdGluZyB0aGUgQUkgc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gKiBzdGF0ZS51cGRhdGUoeyAuLi5zdGF0ZS5nZXQoKSwga2V5OiAndmFsdWUnIH0pXG4gKiBzdGF0ZS51cGRhdGUoKGN1cnJlbnRTdGF0ZSkgPT4gKHsgLi4uY3VycmVudFN0YXRlLCBrZXk6ICd2YWx1ZScgfSkpXG4gKiBzdGF0ZS5kb25lKClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICogc3RhdGUuZG9uZSh7IC4uLnN0YXRlLmdldCgpLCBrZXk6ICd2YWx1ZScgfSkgLy8gRG9uZSB3aXRoIGEgbmV3IHN0YXRlXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBNdXRhYmxlQUlTdGF0ZTxcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XG4+O1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBNdXRhYmxlQUlTdGF0ZTxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+O1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgdHlwZSBBSVN0YXRlID0gSW5mZXJBSVN0YXRlPEFJLCBhbnk+O1xuICB0eXBlIEFJU3RhdGVXaXRoS2V5ID0gdHlwZW9mIGFyZ3MgZXh0ZW5kcyBba2V5OiBrZXlvZiBBSVN0YXRlXVxuICAgID8gQUlTdGF0ZVsodHlwZW9mIGFyZ3MpWzBdXVxuICAgIDogQUlTdGF0ZTtcbiAgdHlwZSBOZXdTdGF0ZU9yVXBkYXRlciA9IFZhbHVlT3JVcGRhdGVyPEFJU3RhdGVXaXRoS2V5PjtcblxuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXG4gICAgJ2BnZXRNdXRhYmxlQUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIEFJIEFjdGlvbi4nLFxuICApO1xuXG4gIGlmIChzdG9yZS5zZWFsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBnZXRNdXRhYmxlQUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHJldHVybmluZyBmcm9tIGFuIEFJIEFjdGlvbi4gUGxlYXNlIG1vdmUgaXQgdG8gdGhlIHRvcCBsZXZlbCBvZiB0aGUgQWN0aW9uJ3MgZnVuY3Rpb24gYm9keS5cIixcbiAgICApO1xuICB9XG5cbiAgaWYgKCFzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZSkge1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZSA9IHByb21pc2U7XG4gICAgc3RvcmUubXV0YXRpb25EZWx0YVJlc29sdmUgPSByZXNvbHZlO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9VcGRhdGUobmV3U3RhdGU6IE5ld1N0YXRlT3JVcGRhdGVyLCBkb25lOiBib29sZWFuKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IGNhbid0IG1vZGlmeSB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICApfVwiIGZpZWxkIG9mIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0gPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGUoc3RvcmUuY3VycmVudFN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0gPSBuZXdTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0b3JlLm9wdGlvbnMub25TZXRBSVN0YXRlPy4oe1xuICAgICAga2V5OiBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzWzBdIDogdW5kZWZpbmVkLFxuICAgICAgc3RhdGU6IHN0b3JlLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGRvbmUsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBtdXRhYmxlU3RhdGUgPSB7XG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGUgYXMgQUlTdGF0ZTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG5ld0FJU3RhdGU6IE5ld1N0YXRlT3JVcGRhdGVyKSB7XG4gICAgICBkb1VwZGF0ZShuZXdBSVN0YXRlLCBmYWxzZSk7XG4gICAgfSxcbiAgICBkb25lOiBmdW5jdGlvbiBkb25lKC4uLmRvbmVBcmdzOiBbXSB8IFtOZXdTdGF0ZU9yVXBkYXRlcl0pIHtcbiAgICAgIGlmIChkb25lQXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvVXBkYXRlKGRvbmVBcmdzWzBdIGFzIE5ld1N0YXRlT3JVcGRhdGVyLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsdGEgPSBqc29uZGlmZnBhdGNoLmRpZmYoc3RvcmUub3JpZ2luYWxTdGF0ZSwgc3RvcmUuY3VycmVudFN0YXRlKTtcbiAgICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlIShkZWx0YSk7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gbXV0YWJsZVN0YXRlO1xufVxuXG5leHBvcnQgeyBnZXRBSVN0YXRlLCBnZXRNdXRhYmxlQUlTdGF0ZSB9O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8VCA9IGFueT4oKSB7XG4gIGxldCByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWQsIHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZSEsXG4gICAgcmVqZWN0OiByZWplY3QhLFxuICB9O1xufVxuXG4vLyBVc2UgdGhlIG5hbWUgYFJgIGZvciBgUm93YCBhcyBpdCB3aWxsIGJlIHNob3J0ZXIgaW4gdGhlIFJTQyBwYXlsb2FkLlxuY29uc3QgUiA9IFtcbiAgKGFzeW5jICh7XG4gICAgYywgLy8gY3VycmVudFxuICAgIG4sIC8vIG5leHRcbiAgfToge1xuICAgIGM6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBuOiBQcm9taXNlPGFueT47XG4gIH0pID0+IHtcbiAgICBjb25zdCBjaHVuayA9IGF3YWl0IG47XG4gICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsuYXBwZW5kKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIHtjfVxuICAgICAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICAgICAgPC9TdXNwZW5zZT5cbiAgICAgICAgPC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICk7XG4gIH0pIGFzIHVua25vd24gYXMgUmVhY3QuRkM8e1xuICAgIGM6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBuOiBQcm9taXNlPGFueT47XG4gIH0+LFxuXVswXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlZENodW5rKGluaXRpYWxWYWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuXG4gIHJldHVybiB7XG4gICAgcm93OiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2luaXRpYWxWYWx1ZX0+XG4gICAgICAgIDxSIGM9e2luaXRpYWxWYWx1ZX0gbj17cHJvbWlzZX0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAoeDogdW5rbm93bik6IHggaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBjb25zdW1lU3RyZWFtID0gYXN5bmMgKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pID0+IHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG4gIH1cbn07XG4iLCJpbXBvcnQgdHlwZSB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gJ3pvZC10by1qc29uLXNjaGVtYSc7XG5cbi8vIFRPRE86IFRoaXMgbmVlZHMgdG8gYmUgZXh0ZXJuYWxpemVkLlxuaW1wb3J0IHsgT3BlbkFJU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtcyc7XG5cbmltcG9ydCB7XG4gIFNUUkVBTUFCTEVfVkFMVUVfVFlQRSxcbiAgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlLFxuICBjcmVhdGVTdXNwZW5zZWRDaHVuayxcbiAgY29uc3VtZVN0cmVhbSxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFN0cmVhbWFibGVQYXRjaCwgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQ3JlYXRlIGEgcGllY2Ugb2YgY2hhbmdhYmxlIFVJIHRoYXQgY2FuIGJlIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQuXG4gKiBPbiB0aGUgY2xpZW50IHNpZGUsIGl0IGNhbiBiZSByZW5kZXJlZCBhcyBhIG5vcm1hbCBSZWFjdCBub2RlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbFZhbHVlPzogUmVhY3QuUmVhY3ROb2RlKSB7XG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHsgcm93LCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVN1c3BlbnNlZENodW5rKGluaXRpYWxWYWx1ZSk7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U3RyZWFtKG1ldGhvZDogc3RyaW5nKSB7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICc6IFVJIHN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICBsZXQgd2FybmluZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuICBmdW5jdGlvbiB3YXJuVW5jbG9zZWRTdHJlYW0oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnVGhlIHN0cmVhbWFibGUgVUkgaGFzIGJlZW4gc2xvdyB0byB1cGRhdGUuIFRoaXMgbWF5IGJlIGEgYnVnIG9yIGEgcGVyZm9ybWFuY2UgaXNzdWUgb3IgeW91IGZvcmdvdCB0byBjYWxsIGAuZG9uZSgpYC4nLFxuICAgICAgICApO1xuICAgICAgfSwgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUpO1xuICAgIH1cbiAgfVxuICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICBjb25zdCBzdHJlYW1hYmxlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZSBVSS4gVGhpcyBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFNlcnZlciBBY3Rpb24gYW5kIHJlY2VpdmVkIGJ5IHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgdmFsdWU6IHJvdyxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IFVJIG5vZGUuIEl0IHRha2VzIGEgbmV3IFVJIG5vZGUgYW5kIHJlcGxhY2VzIHRoZSBvbGQgb25lLlxuICAgICAqL1xuICAgIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy51cGRhdGUoKScpO1xuXG4gICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHVwZGF0ZSB0aGUgdmFsdWUgaWYgaXQncyByZWZlcmVudGlhbGx5IGVxdWFsLlxuICAgICAgaWYgKHZhbHVlID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogZmFsc2UsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBuZXcgVUkgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBvbGQgb25lLlxuICAgICAqIE9uY2UgYXBwZW5kZWQgYSBuZXcgVUkgbm9kZSwgdGhlIHByZXZpb3VzIFVJIG5vZGUgY2Fubm90IGJlIHVwZGF0ZWQgYW55bW9yZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganN4XG4gICAgICogY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoPGRpdj5oZWxsbzwvZGl2PilcbiAgICAgKiB1aS5hcHBlbmQoPGRpdj53b3JsZDwvZGl2PilcbiAgICAgKlxuICAgICAqIC8vIFRoZSBVSSBub2RlIHdpbGwgYmU6XG4gICAgICogLy8gPD5cbiAgICAgKiAvLyAgIDxkaXY+aGVsbG88L2Rpdj5cbiAgICAgKiAvLyAgIDxkaXY+d29ybGQ8L2Rpdj5cbiAgICAgKiAvLyA8Lz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhcHBlbmQodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuYXBwZW5kKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgcmVzb2x2ZSh7IHZhbHVlLCBkb25lOiBmYWxzZSwgYXBwZW5kOiB0cnVlLCBuZXh0OiByZXNvbHZhYmxlLnByb21pc2UgfSk7XG4gICAgICByZXNvbHZlID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVqZWN0ID0gcmVzb2x2YWJsZS5yZWplY3Q7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIFVJIHN0cmVhbS5cbiAgICAgKiBJdCB3aWxsIGJlIHRocm93biBvbiB0aGUgY2xpZW50IHNpZGUgYW5kIGNhdWdodCBieSB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSBjb21wb25lbnQuXG4gICAgICovXG4gICAgZXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZXJyb3IoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICByZWplY3QoZXJyb3IpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSBVSSBub2RlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0IGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgVUkgbm9kZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAgICogT25jZSBjYWxsZWQsIHRoZSBVSSBub2RlIGNhbm5vdCBiZSB1cGRhdGVkIG9yIGFwcGVuZGVkIGFueW1vcmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZSB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICAgKi9cbiAgICBkb25lKC4uLmFyZ3M6IFtdIHwgW1JlYWN0LlJlYWN0Tm9kZV0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBhcmdzWzBdLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBzdHJlYW1hYmxlO1xufVxuXG5jb25zdCBTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0sgPSBTeW1ib2woJ3N0cmVhbWFibGUudmFsdWUubG9jaycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHdyYXBwZWQsIGNoYW5nYWJsZSB2YWx1ZSB0aGF0IGNhbiBiZSBzdHJlYW1lZCB0byB0aGUgY2xpZW50LlxuICogT24gdGhlIGNsaWVudCBzaWRlLCB0aGUgdmFsdWUgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgcmVhZFN0cmVhbWFibGVWYWx1ZSgpIEFQSS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVZhbHVlPFQgPSBhbnksIEUgPSBhbnk+KFxuICBpbml0aWFsVmFsdWU/OiBUIHwgUmVhZGFibGVTdHJlYW08VD4sXG4pIHtcbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9XG4gICAgaW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHxcbiAgICAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGluaXRpYWxWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgJ2dldFJlYWRlcicgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgJ2xvY2tlZCcgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmxvY2tlZCA9PT0gJ2Jvb2xlYW4nKTtcblxuICBpZiAoIWlzUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPihpbml0aWFsVmFsdWUpO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPigpO1xuXG4gIC8vIFNpbmNlIHRoZSBzdHJlYW1hYmxlIHZhbHVlIHdpbGwgYmUgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSwgaXQncyBub3QgYWxsb3dlZFxuICAvLyB0byB1cGRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5IGFzIHRoYXQgaW50cm9kdWNlcyByYWNlIGNvbmRpdGlvbnMgYW5kXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gIC8vIFdlIGxvY2sgdGhlIHZhbHVlIHRvIHByZXZlbnQgYW55IHVwZGF0ZXMgZnJvbSB0aGUgdXNlci5cbiAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuXG4gIChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnN1bWUgdGhlIHJlYWRhYmxlIHN0cmVhbSBhbmQgdXBkYXRlIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IHJlYWRlciA9IGluaXRpYWxWYWx1ZS5nZXRSZWFkZXIoKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVubG9jayB0aGUgdmFsdWUgdG8gYWxsb3cgdXBkYXRlcy5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2NrIHRoZSB2YWx1ZSBhZ2Fpbi5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmRvbmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmVycm9yKGUpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gc3RyZWFtYWJsZVZhbHVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQgPSBhbnksIEUgPSBhbnk+KGluaXRpYWxWYWx1ZT86IFQpIHtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgbG9ja2VkID0gZmFsc2U7XG4gIGxldCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PigpO1xuXG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjdXJyZW50RXJyb3I6IEUgfCB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50UHJvbWlzZTogdHlwZW9mIHJlc29sdmFibGUucHJvbWlzZSB8IHVuZGVmaW5lZCA9XG4gICAgcmVzb2x2YWJsZS5wcm9taXNlO1xuICBsZXQgY3VycmVudFBhdGNoVmFsdWU6IFN0cmVhbWFibGVQYXRjaDtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIG1ldGhvZCArICc6IFZhbHVlIHN0cmVhbSBpcyBsb2NrZWQgYW5kIGNhbm5vdCBiZSB1cGRhdGVkLicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWQoaW5pdGlhbENodW5rPzogYm9vbGVhbik6IFN0cmVhbWFibGVWYWx1ZTxULCBFPiB7XG4gICAgLy8gVGhpcyBtYWtlcyB0aGUgcGF5bG9hZCBtdWNoIHNtYWxsZXIgaWYgdGhlcmUncmUgbXV0YXRpdmUgdXBkYXRlcyBiZWZvcmUgdGhlIGZpcnN0IHJlYWQuXG4gICAgbGV0IGluaXQ6IFBhcnRpYWw8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAgIGlmIChjdXJyZW50RXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdCA9IHsgZXJyb3I6IGN1cnJlbnRFcnJvciB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFBhdGNoVmFsdWUgJiYgIWluaXRpYWxDaHVuaykge1xuICAgICAgICBpbml0ID0geyBkaWZmOiBjdXJyZW50UGF0Y2hWYWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdCA9IHsgY3VycjogY3VycmVudFZhbHVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICBpbml0Lm5leHQgPSBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbENodW5rKSB7XG4gICAgICBpbml0LnR5cGUgPSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGBjdXJyZW50VmFsdWVgIGFuZCBgY3VycmVudFBhdGNoVmFsdWVgIGlmIG5lZWRlZC5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWVTdGF0ZXModmFsdWU6IFQpIHtcbiAgICAvLyBJZiB3ZSBjYW4gb25seSBzZW5kIGEgcGF0Y2ggb3ZlciB0aGUgd2lyZSwgaXQncyBiZXR0ZXIgdG8gZG8gc28uXG4gICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMCwgdmFsdWUuc2xpY2UoY3VycmVudFZhbHVlLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlID0ge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCBUaGlzIGlzIGFuIGludGVybmFsIGxvY2sgdG8gcHJldmVudCB0aGUgdmFsdWUgZnJvbSBiZWluZ1xuICAgICAqIHVwZGF0ZWQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2V0IFtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdKHN0YXRlOiBib29sZWFuKSB7XG4gICAgICBsb2NrZWQgPSBzdGF0ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZS4gVGhpcyBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFNlcnZlciBBY3Rpb24gYW5kXG4gICAgICogcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC4gVG8gcmVhZCB0aGUgc3RyZWFtZWQgdmFsdWVzLCB1c2UgdGhlXG4gICAgICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZWQodHJ1ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IHZhbHVlIHdpdGggYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHVwZGF0ZSh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKHZhbHVlKTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgZGVsdGEgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHZhbHVlLiBJdFxuICAgICAqIHJlcXVpcmVzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIHRvIGJlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBjb25zdCBzdHJlYW1hYmxlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCdoZWxsbycpO1xuICAgICAqIHN0cmVhbWFibGUuYXBwZW5kKCcgd29ybGQnKTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSB2YWx1ZSB3aWxsIGJlICdoZWxsbyB3b3JsZCdcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhcHBlbmQodmFsdWU6IFQpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmFwcGVuZCgpJyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgdHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYC5hcHBlbmQoKTogVGhlIGN1cnJlbnQgdmFsdWUgaXMgbm90IGEgc3RyaW5nLiBSZWNlaXZlZDogJHt0eXBlb2YgY3VycmVudFZhbHVlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYC5hcHBlbmQoKTogVGhlIHZhbHVlIGlzIG5vdCBhIHN0cmluZy4gUmVjZWl2ZWQ6ICR7dHlwZW9mIHZhbHVlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMCwgdmFsdWVdO1xuICAgICAgICAoY3VycmVudFZhbHVlIGFzIHN0cmluZykgPSBjdXJyZW50VmFsdWUgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgICByZXNvbHZlUHJldmlvdXMoY3JlYXRlV3JhcHBlZCgpKTtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzaWduYWwgdGhhdCB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgdmFsdWUgc3RyZWFtLlxuICAgICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSB3aGVuIGNvbnN1bWVkIHZpYVxuICAgICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYC5cbiAgICAgKi9cbiAgICBlcnJvcihlcnJvcjogYW55KSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5lcnJvcigpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRFcnJvciA9IGVycm9yO1xuICAgICAgY3VycmVudFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7IGVycm9yIH0pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSB2YWx1ZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dFxuICAgICAqIGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgdmFsdWUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgICAqIE9uY2UgY2FsbGVkLCB0aGUgdmFsdWUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsd2F5cyAqKnJlcXVpcmVkKiogdG8gYmUgY2FsbGVkLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlXG4gICAgICogd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZG9uZSguLi5hcmdzOiBbXSB8IFtUXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdXBkYXRlVmFsdWVTdGF0ZXMoYXJnc1swXSk7XG4gICAgICAgIHJlc29sdmFibGUucmVzb2x2ZShjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHt9KTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtYWJsZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJLCBjcmVhdGVTdHJlYW1hYmxlVmFsdWUgfTtcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xudHlwZSBSZW5kZXJlcjxUPiA9IChcbiAgcHJvcHM6IFQsXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG4vKipcbiAqIGByZW5kZXJgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBzb21lIExMTXMuXG4gKiBUaGlzIEFQSSBvbmx5IHN1cHBvcnRzIE9wZW5BSSdzIEdQVCBtb2RlbHMgd2l0aCBGdW5jdGlvbiBDYWxsaW5nIGFuZCBBc3Npc3RhbnRzIFRvb2xzLFxuICogcGxlYXNlIHVzZSBgc3RyZWFtVUlgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgcHJvdmlkZXJzLlxuICpcbiAqIEBkZXByZWNhdGVkIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBgc3RyZWFtVUlgIEFQSSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFJIFNESyBDb3JlIEFQSXNcbiAqIGFuZCBmdXR1cmUgZmVhdHVyZXMuIFRoaXMgQVBJIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyPFxuICBUUyBleHRlbmRzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogei5TY2hlbWE7XG4gIH0gPSB7fSxcbiAgRlMgZXh0ZW5kcyB7XG4gICAgW25hbWU6IHN0cmluZ106IHouU2NoZW1hO1xuICB9ID0ge30sXG4+KG9wdGlvbnM6IHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBuYW1lIHRvIHVzZS4gTXVzdCBiZSBPcGVuQUkgU0RLIGNvbXBhdGlibGUuIFRvb2xzIGFuZCBGdW5jdGlvbnMgYXJlIG9ubHkgc3VwcG9ydGVkXG4gICAqIEdQVCBtb2RlbHMgKDMuNS80KSwgT3BlbkFJIEFzc2lzdGFudHMsIE1pc3RyYWwgc21hbGwgYW5kIGxhcmdlLCBhbmQgRmlyZXdvcmtzIGZpcmVmdW5jdGlvbi12MS5cbiAgICpcbiAgICogQGV4YW1wbGUgXCJncHQtMy41LXR1cmJvXCJcbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcHJvdmlkZXIgaW5zdGFuY2UgdG8gdXNlLiBDdXJyZW50bHkgdGhlIG9ubHkgcHJvdmlkZXIgYXZhaWxhYmxlIGlzIE9wZW5BSS5cbiAgICogVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgbW9kZWwgbmFtZS5cbiAgICovXG4gIHByb3ZpZGVyOiBPcGVuQUk7XG4gIG1lc3NhZ2VzOiBQYXJhbWV0ZXJzPFxuICAgIHR5cGVvZiBPcGVuQUkucHJvdG90eXBlLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlXG4gID5bMF1bJ21lc3NhZ2VzJ107XG4gIHRleHQ/OiBSZW5kZXJlcjx7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNvIGZhci5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIG5ldyBhcHBlbmRlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc2luY2UgdGhlIGxhc3QgYHRleHRgIGNhbGwuXG4gICAgICovXG4gICAgZGVsdGE6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBgY29udGVudGAgd2lsbCBiZSB0aGUgZmluYWwgb3V0cHV0IGFuZCB0aGlzIGNhbGwgd2lsbCBiZSB0aGUgbGFzdC5cbiAgICAgKi9cbiAgICBkb25lOiBib29sZWFuO1xuICB9PjtcbiAgdG9vbHM/OiB7XG4gICAgW25hbWUgaW4ga2V5b2YgVFNdOiB7XG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IFRTW25hbWVdO1xuICAgICAgcmVuZGVyOiBSZW5kZXJlcjx6LmluZmVyPFRTW25hbWVdPj47XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb25zPzoge1xuICAgIFtuYW1lIGluIGtleW9mIEZTXToge1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICBwYXJhbWV0ZXJzOiBGU1tuYW1lXTtcbiAgICAgIHJlbmRlcjogUmVuZGVyZXI8ei5pbmZlcjxGU1tuYW1lXT4+O1xuICAgIH07XG4gIH07XG4gIGluaXRpYWw/OiBSZWFjdE5vZGU7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xufSk6IFJlYWN0Tm9kZSB7XG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKG9wdGlvbnMuaW5pdGlhbCk7XG5cbiAgLy8gVGhlIGRlZmF1bHQgdGV4dCByZW5kZXJlciBqdXN0IHJldHVybnMgdGhlIGNvbnRlbnQgYXMgc3RyaW5nLlxuICBjb25zdCB0ZXh0ID0gb3B0aW9ucy50ZXh0XG4gICAgPyBvcHRpb25zLnRleHRcbiAgICA6ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT4gY29udGVudDtcblxuICBjb25zdCBmdW5jdGlvbnMgPSBvcHRpb25zLmZ1bmN0aW9uc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5mdW5jdGlvbnMpLm1hcChcbiAgICAgICAgKFtuYW1lLCB7IGRlc2NyaXB0aW9uLCBwYXJhbWV0ZXJzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHpvZFRvSnNvblNjaGVtYShwYXJhbWV0ZXJzKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHRvb2xzID0gb3B0aW9ucy50b29sc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50b29scykubWFwKFxuICAgICAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEocGFyYW1ldGVycykgYXMgUmVjb3JkPFxuICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICB1bmtub3duXG4gICAgICAgICAgICAgID4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGZ1bmN0aW9ucyAmJiB0b29scykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbid0IGhhdmUgYm90aCBmdW5jdGlvbnMgYW5kIHRvb2xzIGRlZmluZWQuIFBsZWFzZSBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci5cIixcbiAgICApO1xuICB9XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihcbiAgICBhcmdzOiBhbnksXG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT4sXG4gICAgcmVzOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+LFxuICApIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoYXJncyk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgKHZhbHVlIGFzIFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPik7XG4gICAgICByZXMudXBkYXRlKG5vZGUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICAgICkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBBc3luY0dlbmVyYXRvcjxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIHZvaWRcbiAgICAgID47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEdlbmVyYXRvcjxSZWFjdC5SZWFjdE5vZGUsIFJlYWN0LlJlYWN0Tm9kZSwgdm9pZD47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBoYXNGdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50ID0gJyc7XG5cbiAgICBjb25zdW1lU3RyZWFtKFxuICAgICAgT3BlbkFJU3RyZWFtKFxuICAgICAgICAoYXdhaXQgb3B0aW9ucy5wcm92aWRlci5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXMsXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMudGVtcGVyYXR1cmUsXG4gICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgIC4uLihmdW5jdGlvbnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pKSBhcyBhbnksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZnVuY3Rpb25DYWxsUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxQYXlsb2FkLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mdW5jdGlvbnM/LltmdW5jdGlvbkNhbGxQYXlsb2FkLm5hbWUgYXMgYW55XVxuICAgICAgICAgICAgICAgICAgICAgID8ucmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25Ub29sQ2FsbCh0b29sQ2FsbFBheWxvYWQ6IGFueSkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCBuZWVkIFByb21pc2UuYWxsIGhlcmU/XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgICB0b29sLmZ1bmMuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbHM/Llt0b29sLmZ1bmMubmFtZSBhcyBhbnldPy5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgb25UZXh0KGNodW5rKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGNodW5rO1xuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiBjaHVuayB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBvbkZpbmFsKCkge1xuICAgICAgICAgICAgaWYgKGhhc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogdHJ1ZSB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgIHVpLmRvbmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9KSgpO1xuXG4gIHJldHVybiB1aS52YWx1ZTtcbn1cbiIsImltcG9ydCB7IEFQSUNhbGxFcnJvciwgUmV0cnlFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi9kZWxheSc7XG5cbmV4cG9ydCB0eXBlIFJldHJ5RnVuY3Rpb24gPSA8T1VUUFVUPihcbiAgZm46ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4sXG4pID0+IFByb21pc2VMaWtlPE9VVFBVVD47XG5cbi8qKlxuVGhlIGByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZgIHN0cmF0ZWd5IHJldHJpZXMgYSBmYWlsZWQgQVBJIGNhbGwgd2l0aCBhbiBleHBvbmVudGlhbCBiYWNrb2ZmLlxuWW91IGNhbiBjb25maWd1cmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsIHRoZSBpbml0aWFsIGRlbGF5LCBhbmQgdGhlIGJhY2tvZmYgZmFjdG9yLlxuICovXG5leHBvcnQgY29uc3QgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID1cbiAgKHtcbiAgICBtYXhSZXRyaWVzID0gMixcbiAgICBpbml0aWFsRGVsYXlJbk1zID0gMjAwMCxcbiAgICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgfSA9IHt9KTogUmV0cnlGdW5jdGlvbiA9PlxuICBhc3luYyA8T1VUUFVUPihmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+KSA9PlxuICAgIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgfSk7XG5cbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmY8T1VUUFVUPihcbiAgZjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbiAge1xuICAgIG1heFJldHJpZXMsXG4gICAgZGVsYXlJbk1zLFxuICAgIGJhY2tvZmZGYWN0b3IsXG4gIH06IHsgbWF4UmV0cmllczogbnVtYmVyOyBkZWxheUluTXM6IG51bWJlcjsgYmFja29mZkZhY3RvcjogbnVtYmVyIH0sXG4gIGVycm9yczogdW5rbm93bltdID0gW10sXG4pOiBQcm9taXNlPE9VVFBVVD4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCByZXRyeSB3aGVuIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIHJldHJpZXMgYXJlIGRpc2FibGVkXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcblxuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246ICdtYXhSZXRyaWVzRXhjZWVkZWQnLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiZcbiAgICAgIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmXG4gICAgICB0cnlOdW1iZXIgPD0gbWF4UmV0cmllc1xuICAgICkge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIGEgbm9uLXJldHJ5YWJsZSBlcnJvciBvY2N1cnMgb24gdGhlIGZpcnN0IHRyeVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiAnZXJyb3JOb3RSZXRyeWFibGUnLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuIiwiY29uc3QgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiAnaW1hZ2UvZ2lmJyBhcyBjb25zdCwgYnl0ZXM6IFsweDQ3LCAweDQ5LCAweDQ2XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvcG5nJyBhcyBjb25zdCwgYnl0ZXM6IFsweDg5LCAweDUwLCAweDRlLCAweDQ3XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvanBlZycgYXMgY29uc3QsIGJ5dGVzOiBbMHhmZiwgMHhkOF0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3dlYnAnIGFzIGNvbnN0LCBieXRlczogWzB4NTIsIDB4NDksIDB4NDYsIDB4NDZdIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShcbiAgaW1hZ2U6IFVpbnQ4QXJyYXksXG4pOiAnaW1hZ2UvanBlZycgfCAnaW1hZ2UvcG5nJyB8ICdpbWFnZS9naWYnIHwgJ2ltYWdlL3dlYnAnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChcbiAgICAgIGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiZcbiAgICAgIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5cbi8qKlxuRGF0YSBjb250ZW50LiBDYW4gZWl0aGVyIGJlIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlci5cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YUNvbnRlbnQgPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBCdWZmZXI7XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50OiBEYXRhQ29udGVudCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cblxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cblxuLyoqXG5Db252ZXJ0cyBkYXRhIGNvbnRlbnQgdG8gYSBVaW50OEFycmF5LlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgY29udGVudDogRGF0YUNvbnRlbnQsXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgaW1hZ2UuJyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG4iLCJpbXBvcnQge1xuICBMYW5ndWFnZU1vZGVsVjFJbWFnZVBhcnQsXG4gIExhbmd1YWdlTW9kZWxWMU1lc3NhZ2UsXG4gIExhbmd1YWdlTW9kZWxWMVByb21wdCxcbiAgTGFuZ3VhZ2VNb2RlbFYxVGV4dFBhcnQsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZGV0ZWN0SW1hZ2VNaW1lVHlwZSB9IGZyb20gJy4uL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlJztcbmltcG9ydCB7IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSB9IGZyb20gJy4vZGF0YS1jb250ZW50JztcbmltcG9ydCB7IFZhbGlkYXRlZFByb21wdCB9IGZyb20gJy4vZ2V0LXZhbGlkYXRlZC1wcm9tcHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdChcbiAgcHJvbXB0OiBWYWxpZGF0ZWRQcm9tcHQsXG4pOiBMYW5ndWFnZU1vZGVsVjFQcm9tcHQge1xuICBjb25zdCBsYW5ndWFnZU1vZGVsTWVzc2FnZXM6IExhbmd1YWdlTW9kZWxWMVByb21wdCA9IFtdO1xuXG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH0pO1xuICB9XG5cbiAgc3dpdGNoIChwcm9tcHQudHlwZSkge1xuICAgIGNhc2UgJ3Byb21wdCc6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IHByb21wdC5wcm9tcHQgfV0sXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ21lc3NhZ2VzJzoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoKG1lc3NhZ2UpOiBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgICAgICAgY2FzZSAnc3lzdGVtJzoge1xuICAgICAgICAgICAgICByZXR1cm4geyByb2xlOiAnc3lzdGVtJywgY29udGVudDogbWVzc2FnZS5jb250ZW50IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3VzZXInOiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcChcbiAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAgICk6IExhbmd1YWdlTW9kZWxWMVRleHRQYXJ0IHwgTGFuZ3VhZ2VNb2RlbFYxSW1hZ2VQYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5pbWFnZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHBhcnQuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVaW50OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5taW1lVHlwZSA/PyBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlVWludDgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnYXNzaXN0YW50Jzoge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHsgcm9sZTogJ2Fzc2lzdGFudCcsIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICd0b29sJzoge1xuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gcHJvbXB0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9tcHQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENvcmVNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4vcHJvbXB0JztcblxuZXhwb3J0IHR5cGUgVmFsaWRhdGVkUHJvbXB0ID1cbiAgfCB7XG4gICAgICB0eXBlOiAncHJvbXB0JztcbiAgICAgIHByb21wdDogc3RyaW5nO1xuICAgICAgbWVzc2FnZXM6IHVuZGVmaW5lZDtcbiAgICAgIHN5c3RlbT86IHN0cmluZztcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogJ21lc3NhZ2VzJztcbiAgICAgIHByb21wdDogdW5kZWZpbmVkO1xuICAgICAgbWVzc2FnZXM6IENvcmVNZXNzYWdlW107XG4gICAgICBzeXN0ZW0/OiBzdHJpbmc7XG4gICAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZFByb21wdChwcm9tcHQ6IFByb21wdCk6IFZhbGlkYXRlZFByb21wdCB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkJyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWUnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHByb21wdC5wcm9tcHQgIT0gbnVsbFxuICAgID8ge1xuICAgICAgICB0eXBlOiAncHJvbXB0JyxcbiAgICAgICAgcHJvbXB0OiBwcm9tcHQucHJvbXB0LFxuICAgICAgICBtZXNzYWdlczogdW5kZWZpbmVkLFxuICAgICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICB9XG4gICAgOiB7XG4gICAgICAgIHR5cGU6ICdtZXNzYWdlcycsXG4gICAgICAgIHByb21wdDogdW5kZWZpbmVkLFxuICAgICAgICBtZXNzYWdlczogcHJvbXB0Lm1lc3NhZ2VzISwgLy8gb25seSBwb3NzaWJsZSBjYXNlIGJjIG9mIGNoZWNrcyBhYm92ZVxuICAgICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICB9O1xufVxuIiwiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4vY2FsbC1zZXR0aW5ncyc7XG5cbi8qKlxuICogVmFsaWRhdGVzIGNhbGwgc2V0dGluZ3MgYW5kIHNldHMgZGVmYXVsdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBtYXhSZXRyaWVzLFxufTogQ2FsbFNldHRpbmdzKTogQ2FsbFNldHRpbmdzIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFRva2VucycsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhUb2tlbnMnLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiAnbWF4VG9rZW5zIG11c3QgYmUgPj0gMScsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0ZW1wZXJhdHVyZScsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogJ3RlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3RvcFAnLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogJ3RvcFAgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6ICdwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiAnZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3NlZWQnLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogJ3NlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFJldHJpZXMnLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogJ21heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4UmV0cmllcycsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiAnbWF4UmV0cmllcyBtdXN0IGJlID49IDAnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXhUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmU6IHRlbXBlcmF0dXJlID8/IDAsXG4gICAgdG9wUCxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgPz8gMixcbiAgfTtcbn1cbiIsImltcG9ydCB7IEpTT05TY2hlbWE3IH0gZnJvbSAnanNvbi1zY2hlbWEnO1xuaW1wb3J0ICogYXMgeiBmcm9tICd6b2QnO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tICd6b2QtdG8tanNvbi1zY2hlbWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFpvZFRvSlNPTlNjaGVtYShcbiAgem9kU2NoZW1hOiB6LlNjaGVtYTx1bmtub3duPixcbik6IEpTT05TY2hlbWE3IHtcbiAgLy8gd2UgYXNzdW1lIHRoYXQgem9kVG9Kc29uU2NoZW1hIHdpbGwgcmV0dXJuIGEgdmFsaWQgSlNPTlNjaGVtYTdcbiAgcmV0dXJuIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEpIGFzIEpTT05TY2hlbWE3O1xufVxuIiwiaW1wb3J0IHsgVG9vbENhbGwgYXMgQ29yZVRvb2xDYWxsIH0gZnJvbSAnLi4vY29yZS9nZW5lcmF0ZS10ZXh0L3Rvb2wtY2FsbCc7XG5pbXBvcnQgeyBUb29sUmVzdWx0IGFzIENvcmVUb29sUmVzdWx0IH0gZnJvbSAnLi4vY29yZS9nZW5lcmF0ZS10ZXh0L3Rvb2wtcmVzdWx0JztcbmltcG9ydCB7XG4gIEFzc2lzdGFudE1lc3NhZ2UsXG4gIERhdGFNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgU3RyZWFtU3RyaW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtUGFydDxDT0RFIGV4dGVuZHMgc3RyaW5nLCBOQU1FIGV4dGVuZHMgc3RyaW5nLCBUWVBFPiB7XG4gIGNvZGU6IENPREU7XG4gIG5hbWU6IE5BTUU7XG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4geyB0eXBlOiBOQU1FOyB2YWx1ZTogVFlQRSB9O1xufVxuXG5jb25zdCB0ZXh0U3RyZWFtUGFydDogU3RyZWFtUGFydDwnMCcsICd0ZXh0Jywgc3RyaW5nPiA9IHtcbiAgY29kZTogJzAnLFxuICBuYW1lOiAndGV4dCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgZnVuY3Rpb25DYWxsU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzEnLFxuICAnZnVuY3Rpb25fY2FsbCcsXG4gIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH1cbj4gPSB7XG4gIGNvZGU6ICcxJyxcbiAgbmFtZTogJ2Z1bmN0aW9uX2NhbGwnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdmdW5jdGlvbl9jYWxsJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSAnb2JqZWN0JyB8fFxuICAgICAgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8XG4gICAgICAhKCduYW1lJyBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fFxuICAgICAgISgnYXJndW1lbnRzJyBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZnVuY3Rpb25fY2FsbFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZnVuY3Rpb25fY2FsbFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb25fY2FsbCcsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyB7IGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbCB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBkYXRhU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMicsICdkYXRhJywgQXJyYXk8SlNPTlZhbHVlPj4gPSB7XG4gIGNvZGU6ICcyJyxcbiAgbmFtZTogJ2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnZGF0YScsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBlcnJvclN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzMnLCAnZXJyb3InLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMycsXG4gIG5hbWU6ICdlcnJvcicsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdlcnJvcicsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzQnLFxuICAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICBBc3Npc3RhbnRNZXNzYWdlXG4+ID0ge1xuICBjb2RlOiAnNCcsXG4gIG5hbWU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2lkJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnY29udGVudCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuaWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdhc3Npc3RhbnQnIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS5jb250ZW50KSB8fFxuICAgICAgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAgIGl0ZW0gPT5cbiAgICAgICAgICBpdGVtICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndHlwZScgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgICAgJ3RleHQnIGluIGl0ZW0gJiZcbiAgICAgICAgICBpdGVtLnRleHQgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ3ZhbHVlJyBpbiBpdGVtLnRleHQgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSAnc3RyaW5nJyxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIEFzc2lzdGFudE1lc3NhZ2UsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzUnLFxuICAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gIHtcbiAgICB0aHJlYWRJZDogc3RyaW5nO1xuICAgIG1lc3NhZ2VJZDogc3RyaW5nO1xuICB9XG4+ID0ge1xuICBjb2RlOiAnNScsXG4gIG5hbWU6ICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndGhyZWFkSWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgnbWVzc2FnZUlkJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWQsXG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBkYXRhTWVzc2FnZVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzYnLCAnZGF0YV9tZXNzYWdlJywgRGF0YU1lc3NhZ2U+ID0ge1xuICBjb2RlOiAnNicsXG4gIG5hbWU6ICdkYXRhX21lc3NhZ2UnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdyb2xlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ2RhdGEnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnJvbGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZS5yb2xlICE9PSAnZGF0YSdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZGF0YV9tZXNzYWdlJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyBEYXRhTWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgdG9vbENhbGxzU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzcnLFxuICAndG9vbF9jYWxscycsXG4gIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9XG4+ID0ge1xuICBjb2RlOiAnNycsXG4gIG5hbWU6ICd0b29sX2NhbGxzJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndG9vbF9jYWxscycgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHxcbiAgICAgIHZhbHVlLnRvb2xfY2FsbHMuc29tZShcbiAgICAgICAgdGMgPT5cbiAgICAgICAgICB0YyA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2lkJyBpbiB0YykgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuaWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgISgndHlwZScgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLnR5cGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgISgnZnVuY3Rpb24nIGluIHRjKSB8fFxuICAgICAgICAgIHRjLmZ1bmN0aW9uID09IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgISgnYXJndW1lbnRzJyBpbiB0Yy5mdW5jdGlvbikgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24ubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24uYXJndW1lbnRzICE9PSAnc3RyaW5nJyxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Rvb2xfY2FsbHMnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgeyB0b29sX2NhbGxzOiBUb29sQ2FsbFtdIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc4JyxcbiAgJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLFxuICBBcnJheTxKU09OVmFsdWU+XG4+ID0ge1xuICBjb2RlOiAnOCcsXG4gIG5hbWU6ICdtZXNzYWdlX2Fubm90YXRpb25zJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgdG9vbENhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnOScsXG4gICd0b29sX2NhbGwnLFxuICBDb3JlVG9vbENhbGw8c3RyaW5nLCBhbnk+XG4+ID0ge1xuICBjb2RlOiAnOScsXG4gIG5hbWU6ICd0b29sX2NhbGwnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0b29sQ2FsbElkJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgISgndG9vbE5hbWUnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xOYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgISgnYXJncycgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuYXJncyAhPT0gJ29iamVjdCdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIsIFwidG9vbE5hbWVcIiwgYW5kIFwiYXJnc1wiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndG9vbF9jYWxsJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIENvcmVUb29sQ2FsbDxzdHJpbmcsIGFueT4sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHRvb2xSZXN1bHRTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnYScsXG4gICd0b29sX3Jlc3VsdCcsXG4gIENvcmVUb29sUmVzdWx0PHN0cmluZywgYW55LCBhbnk+XG4+ID0ge1xuICBjb2RlOiAnYScsXG4gIG5hbWU6ICd0b29sX3Jlc3VsdCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Rvb2xDYWxsSWQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICAhKCd0b29sTmFtZScgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAhKCdhcmdzJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5hcmdzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgncmVzdWx0JyBpbiB2YWx1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9yZXN1bHRcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiwgXCJ0b29sTmFtZVwiLCBcImFyZ3NcIiwgYW5kIFwicmVzdWx0XCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0b29sX3Jlc3VsdCcsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyBDb3JlVG9vbFJlc3VsdDxzdHJpbmcsIGFueSwgYW55PixcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3Qgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsc1N0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgdG9vbFJlc3VsdFN0cmVhbVBhcnQsXG5dIGFzIGNvbnN0O1xuXG4vLyB1bmlvbiB0eXBlIG9mIGFsbCBzdHJlYW0gcGFydHNcbnR5cGUgU3RyZWFtUGFydHMgPVxuICB8IHR5cGVvZiB0ZXh0U3RyZWFtUGFydFxuICB8IHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGVycm9yU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIHRvb2xDYWxsc1N0cmVhbVBhcnRcbiAgfCB0eXBlb2YgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydFxuICB8IHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgdG9vbFJlc3VsdFN0cmVhbVBhcnQ7XG5cbi8qKlxuICogTWFwcyB0aGUgdHlwZSBvZiBhIHN0cmVhbSBwYXJ0IHRvIGl0cyB2YWx1ZSB0eXBlLlxuICovXG50eXBlIFN0cmVhbVBhcnRWYWx1ZVR5cGUgPSB7XG4gIFtQIGluIFN0cmVhbVBhcnRzIGFzIFBbJ25hbWUnXV06IFJldHVyblR5cGU8UFsncGFyc2UnXT5bJ3ZhbHVlJ107XG59O1xuXG5leHBvcnQgdHlwZSBTdHJlYW1QYXJ0VHlwZSA9XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdGV4dFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBkYXRhU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBlcnJvclN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0b29sQ2FsbHNTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdG9vbENhbGxTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRvb2xSZXN1bHRTdHJlYW1QYXJ0LnBhcnNlPjtcblxuZXhwb3J0IGNvbnN0IHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsc1N0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsc1N0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFt0b29sUmVzdWx0U3RyZWFtUGFydC5jb2RlXTogdG9vbFJlc3VsdFN0cmVhbVBhcnQsXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIFRoZSBtYXAgb2YgcHJlZml4ZXMgZm9yIGRhdGEgaW4gdGhlIHN0cmVhbVxuICpcbiAqIC0gMDogVGV4dCBmcm9tIHRoZSBMTE0gcmVzcG9uc2VcbiAqIC0gMTogKE9wZW5BSSkgZnVuY3Rpb25fY2FsbCByZXNwb25zZXNcbiAqIC0gMjogY3VzdG9tIEpTT04gYWRkZWQgYnkgdGhlIHVzZXIgdXNpbmcgYERhdGFgXG4gKiAtIDY6IChPcGVuQUkpIHRvb2xfY2FsbCByZXNwb25zZXNcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiAwOlZlcmNlbFxuICogMDonc1xuICogMDogQUlcbiAqIDA6IEFJXG4gKiAwOiBTREtcbiAqIDA6IGlzIGdyZWF0XG4gKiAwOiFcbiAqIDI6IHsgXCJzb21lSnNvblwiOiBcInZhbHVlXCIgfVxuICogMToge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fVxuICogNjoge1widG9vbF9jYWxsXCI6IHtcImlkXCI6IFwidG9vbF8wXCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIiwgXCJhcmd1bWVudHNcIjogXCJ7XFxcXG5cXFxcXCJsb2NhdGlvblxcXFxcIjogXFxcXFwiQ2hhcmxvdHRlc3ZpbGxlLCBWaXJnaW5pYVxcXFxcIixcXFxcblxcXFxcImZvcm1hdFxcXFxcIjogXFxcXFwiY2Vsc2l1c1xcXFxcIlxcXFxufVwifX19XG4gKmBgYFxuICovXG5leHBvcnQgY29uc3QgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbHNTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbHNTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbFJlc3VsdFN0cmVhbVBhcnQubmFtZV06IHRvb2xSZXN1bHRTdHJlYW1QYXJ0LmNvZGUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcChwYXJ0ID0+IHBhcnQuY29kZSk7XG5cbi8qKlxuUGFyc2VzIGEgc3RyZWFtIHBhcnQgZnJvbSBhIHN0cmluZy5cblxuQHBhcmFtIGxpbmUgVGhlIHN0cmluZyB0byBwYXJzZS5cbkByZXR1cm5zIFRoZSBwYXJzZWQgc3RyZWFtIHBhcnQuXG5AdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlU3RyZWFtUGFydCA9IChsaW5lOiBzdHJpbmcpOiBTdHJlYW1QYXJ0VHlwZSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcblxuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuJyk7XG4gIH1cblxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuXG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cblxuICBjb25zdCBjb2RlID0gcHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZTtcblxuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlOiBKU09OVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG5cbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuXG4vKipcblByZXBlbmRzIGEgc3RyaW5nIHdpdGggYSBwcmVmaXggZnJvbSB0aGUgYFN0cmVhbUNodW5rUHJlZml4ZXNgLCBKU09OLWlmaWVzIGl0LFxuYW5kIGFwcGVuZHMgYSBuZXcgbGluZS5cblxuSXQgZW5zdXJlcyB0eXBlLXNhZmV0eSBmb3IgdGhlIHBhcnQgdHlwZSBhbmQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJlYW1QYXJ0PFQgZXh0ZW5kcyBrZXlvZiBTdHJlYW1QYXJ0VmFsdWVUeXBlPihcbiAgdHlwZTogVCxcbiAgdmFsdWU6IFN0cmVhbVBhcnRWYWx1ZVR5cGVbVF0sXG4pOiBTdHJlYW1TdHJpbmcge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZChwYXJ0ID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG5cbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxcbmA7XG59XG4iLCJpbXBvcnQge1xuICBTdHJlYW1QYXJ0VHlwZSxcbiAgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHBhcnNlU3RyZWFtUGFydCxcbn0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxuLy8gVE9ETyByZW1vdmUgKGJyZWFraW5nIGNoYW5nZSlcbmV4cG9ydCB7IGdlbmVyYXRlSWQgYXMgbmFub2lkIH0gZnJvbSAnLi9nZW5lcmF0ZS1pZCc7XG5cbi8vIEV4cG9ydCBzdHJlYW0gZGF0YSB1dGlsaXRpZXMgZm9yIGN1c3RvbSBzdHJlYW0gaW1wbGVtZW50YXRpb25zLFxuLy8gYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZS5cbmV4cG9ydCB0eXBlIHsgU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQsIHBhcnNlU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcblxuLy8gc2ltcGxlIGRlY29kZXIgc2lnbmF0dXJlczpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcigpOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogZmFsc2UsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbi8vIGNvbXBsZXggZGVjb2RlciBzaWduYXR1cmU6XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg6IHRydWUsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IFN0cmVhbVBhcnRUeXBlW107XG4vLyBjb21iaW5lZCBzaWduYXR1cmUgZm9yIHdoZW4gdGhlIGNsaWVudCBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggYSBib29sZWFuOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4PzogYm9vbGVhbixcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXSB8IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4PzogYm9vbGVhbikge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgICBpZiAoIWNodW5rKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXJcbiAgICAgIC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpOyAvLyBzcGxpdHRpbmcgbGVhdmVzIGFuIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kXG5cbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9O1xuXG5leHBvcnQgY29uc3QgaXNTdHJlYW1TdHJpbmdFcXVhbFRvVHlwZSA9IChcbiAgdHlwZToga2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzLFxuICB2YWx1ZTogc3RyaW5nLFxuKTogdmFsdWUgaXMgU3RyZWFtU3RyaW5nID0+XG4gIHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtU3RyaW5nID1cbiAgYCR7KHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlcylba2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzXX06JHtzdHJpbmd9XFxuYDtcbiIsImltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlcixcbiAgdHlwZSBFdmVudFNvdXJjZVBhcnNlcixcbiAgdHlwZSBQYXJzZWRFdmVudCxcbiAgdHlwZSBSZWNvbm5lY3RJbnRlcnZhbCxcbn0gZnJvbSAnZXZlbnRzb3VyY2UtcGFyc2VyJztcbmltcG9ydCB7IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB9IGZyb20gJy4vb3BlbmFpLXN0cmVhbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsUGF5bG9hZCB7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJndW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGxQYXlsb2FkIHtcbiAgdG9vbHM6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6ICdmdW5jdGlvbic7XG4gICAgZnVuYzoge1xuICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgYXJndW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9O1xuICB9W107XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGFuZCBoZWxwZXIgY2FsbGJhY2sgbWV0aG9kcyBmb3IgQUlTdHJlYW0gc3RyZWFtIGxpZmVjeWNsZSBldmVudHMuXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHtcbiAgLyoqIGBvblN0YXJ0YDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGluaXRpYWxpemVkLiAqL1xuICBvblN0YXJ0PzogKCkgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25Db21wbGV0aW9uYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLiAqL1xuICBvbkNvbXBsZXRpb24/OiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvbkZpbmFsYDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGNsb3NlZCB3aXRoIHRoZSBmaW5hbCBjb21wbGV0aW9uIG1lc3NhZ2UuICovXG4gIG9uRmluYWw/OiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvblRva2VuYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLiAqL1xuICBvblRva2VuPzogKHRva2VuOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uVGV4dGA6IENhbGxlZCBmb3IgZWFjaCB0ZXh0IGNodW5rLiAqL1xuICBvblRleHQ/OiAodGV4dDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyBpcyBubyBsb25nZXIgdXNlZCBhbmQgb25seSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAqIFlvdSBjYW4gcmVtb3ZlIGl0IGZyb20geW91ciBjb2RlLlxuICAgKi9cbiAgZXhwZXJpbWVudGFsX3N0cmVhbURhdGE/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSBBSVN0cmVhbVBhcnNlci5cbiAqIEBpbnRlcmZhY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCAodHlwZSkgZnJvbSB0aGUgc2VydmVyIHNpZGUgZXZlbnQgc3RyZWFtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtUGFyc2VyT3B0aW9ucyB7XG4gIGV2ZW50Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEN1c3RvbSBwYXJzZXIgZm9yIEFJU3RyZWFtIGRhdGEuXG4gKiBAaW50ZXJmYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBkYXRhIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdm9pZH0gVGhlIHBhcnNlZCBkYXRhIG9yIHZvaWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1QYXJzZXIge1xuICAoZGF0YTogc3RyaW5nLCBvcHRpb25zOiBBSVN0cmVhbVBhcnNlck9wdGlvbnMpOlxuICAgIHwgc3RyaW5nXG4gICAgfCB2b2lkXG4gICAgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBUcmFuc2Zvcm1TdHJlYW0gdGhhdCBwYXJzZXMgZXZlbnRzIGZyb20gYW4gRXZlbnRTb3VyY2Ugc3RyZWFtIHVzaW5nIGEgY3VzdG9tIHBhcnNlci5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJ9IGN1c3RvbVBhcnNlciAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBldmVudCBkYXRhLlxuICogQHJldHVybnMge1RyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBzdHJpbmc+fSBUcmFuc2Zvcm1TdHJlYW0gcGFyc2luZyBldmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKFxuICBjdXN0b21QYXJzZXI/OiBBSVN0cmVhbVBhcnNlcixcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9PiB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjogRXZlbnRTb3VyY2VQYXJzZXI7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQ6IFBhcnNlZEV2ZW50IHwgUmVjb25uZWN0SW50ZXJ2YWwpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoJ2RhdGEnIGluIGV2ZW50ICYmXG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09ICdldmVudCcgJiZcbiAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9PT0gJ1tET05FXScpIHx8XG4gICAgICAgICAgICAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgICAgKGV2ZW50IGFzIGFueSkuZXZlbnQgPT09ICdkb25lJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2RhdGEnIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyXG4gICAgICAgICAgICAgID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSkgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVuY29kZXMgaW5wdXQgbWVzc2FnZXMgYW5kIGludm9rZXMgb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogVGhlIHRyYW5zZm9ybSBzdHJlYW0gdXNlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIHRvIGV4ZWN1dGUgY3VzdG9tIGxvZ2ljIGF0IGRpZmZlcmVudCBzdGFnZXMgb2YgdGhlIHN0cmVhbSdzIGxpZmVjeWNsZS5cbiAqIC0gYG9uU3RhcnRgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgaW5pdGlhbGl6ZWQuXG4gKiAtIGBvblRva2VuYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLlxuICogLSBgb25Db21wbGV0aW9uYDogQ2FsbGVkIGV2ZXJ5IHRpbWUgYW4gQUlTdHJlYW0gY29tcGxldGlvbiBtZXNzYWdlIGlzIHJlY2VpdmVkLiBUaGlzIGNhbiBvY2N1ciBtdWx0aXBsZSB0aW1lcyB3aGVuIHVzaW5nIGUuZy4gT3BlbkFJIGZ1bmN0aW9uc1xuICogLSBgb25GaW5hbGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBjbG9zZWQgd2l0aCB0aGUgZmluYWwgY29tcGxldGlvbiBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcHJvY2VzcyBhIHN0cmVhbSBvZiBtZXNzYWdlcyBhbmQgcGVyZm9ybSBzcGVjaWZpYyBhY3Rpb25zIGR1cmluZyB0aGUgc3RyZWFtJ3MgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7QUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zfSBbY2FsbGJhY2tzXSAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1TdHJlYW08c3RyaW5nLCBVaW50OEFycmF5Pn0gQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW5jb2RlcyBpbnB1dCBtZXNzYWdlcyBhcyBVaW50OEFycmF5IGFuZCBhbGxvd3MgdGhlIGV4ZWN1dGlvbiBvZiBjdXN0b20gbG9naWMgdGhyb3VnaCBjYWxsYmFja3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNhbGxiYWNrcyA9IHtcbiAqICAgb25TdGFydDogYXN5bmMgKCkgPT4gY29uc29sZS5sb2coJ1N0cmVhbSBzdGFydGVkJyksXG4gKiAgIG9uVG9rZW46IGFzeW5jICh0b2tlbikgPT4gY29uc29sZS5sb2coYFRva2VuOiAke3Rva2VufWApLFxuICogICBvbkNvbXBsZXRpb246IGFzeW5jIChjb21wbGV0aW9uKSA9PiBjb25zb2xlLmxvZyhgQ29tcGxldGlvbjogJHtjb21wbGV0aW9ufWApXG4gKiAgIG9uRmluYWw6IGFzeW5jICgpID0+IGRhdGEuY2xvc2UoKVxuICogfTtcbiAqIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICBjYjogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHwgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIHwgdW5kZWZpbmVkLFxuKTogVHJhbnNmb3JtU3RyZWFtPHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0sIFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9ICcnO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcblxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gbWVzc2FnZSA6IG1lc3NhZ2UuY29udGVudDtcblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG5cbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBjb250ZW50O1xuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKGNvbnRlbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGZsdXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgaXNPcGVuQUlDYWxsYmFja3MgPSBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpO1xuICAgICAgLy8gSWYgaXQncyBPcGVuQUlDYWxsYmFja3MsIGl0IGhhcyBhbiBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXJcbiAgICAgIC8vIHdpbGwgaGFuZGxlIGNhbGxpbmcgb25Db21wbGV0ZS5cbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmICFpc09wZW5BSUNhbGxiYWNrcykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhcbiAgY2FsbGJhY2tzOiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgfCBPcGVuQUlTdHJlYW1DYWxsYmFja3MsXG4pOiBjYWxsYmFja3MgaXMgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIHtcbiAgcmV0dXJuICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwnIGluIGNhbGxiYWNrcztcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0YXRlZnVsIGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgdHJpbXMgbGVhZGluZyB3aGl0ZXNwYWNlXG4gKiBmcm9tIHRoZSBpbnB1dCB0ZXh0LiBUaGUgdHJpbW1pbmcgb25seSBvY2N1cnMgb24gdGhlIGZpcnN0IGludm9jYXRpb24sIGVuc3VyaW5nIHRoYXRcbiAqIHN1YnNlcXVlbnQgY2FsbHMgZG8gbm90IGFsdGVyIHRoZSBpbnB1dCB0ZXh0LiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgaW4gc2NlbmFyaW9zXG4gKiB3aGVyZSBhIHRleHQgc3RyZWFtIGlzIGJlaW5nIHByb2Nlc3NlZCBhbmQgb25seSB0aGUgaW5pdGlhbCB3aGl0ZXNwYWNlIHNob3VsZCBiZSByZW1vdmVkLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZyk6IHN0cmluZ30gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyaW5nIGFzIGlucHV0IGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKiB3aXRoIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkIGlmIGl0IGlzIHRoZSBmaXJzdCBpbnZvY2F0aW9uOyBvdGhlcndpc2UsIGl0IHJldHVybnMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdHJpbVN0YXJ0ID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAqIGNvbnN0IG91dHB1dDEgPSB0cmltU3RhcnQoXCIgICB0ZXh0XCIpOyAvLyBcInRleHRcIlxuICogY29uc3Qgb3V0cHV0MiA9IHRyaW1TdGFydChcIiAgIHRleHRcIik7IC8vIFwiICAgdGV4dFwiXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTogKHRleHQ6IHN0cmluZykgPT4gc3RyaW5nIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuXG4gIHJldHVybiAodGV4dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dCkgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUmVhZGFibGVTdHJlYW0gY3JlYXRlZCBmcm9tIHRoZSByZXNwb25zZSwgcGFyc2VkIGFuZCBoYW5kbGVkIHdpdGggY3VzdG9tIGxvZ2ljLlxuICogVGhlIHN0cmVhbSBnb2VzIHRocm91Z2ggdHdvIHRyYW5zZm9ybWF0aW9uIHN0YWdlcywgZmlyc3QgcGFyc2luZyB0aGUgZXZlbnRzIGFuZCB0aGVuXG4gKiBpbnZva2luZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzLlxuICpcbiAqIEZvciAyeHggSFRUUCByZXNwb25zZXM6XG4gKiAtIFRoZSBmdW5jdGlvbiBjb250aW51ZXMgd2l0aCBzdGFuZGFyZCBzdHJlYW0gcHJvY2Vzc2luZy5cbiAqXG4gKiBGb3Igbm9uLTJ4eCBIVFRQIHJlc3BvbnNlczpcbiAqIC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgZGVmaW5lZCwgaXQgYXN5bmNocm9ub3VzbHkgZXh0cmFjdHMgYW5kIGRlY29kZXMgdGhlIHJlc3BvbnNlIGJvZHkuXG4gKiAtIEl0IHRoZW4gY3JlYXRlcyBhIGN1c3RvbSBSZWFkYWJsZVN0cmVhbSB0byBwcm9wYWdhdGUgYSBkZXRhaWxlZCBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlcn0gY3VzdG9tUGFyc2VyIC0gVGhlIGN1c3RvbSBwYXJzZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9uc30gY2FsbGJhY2tzIC0gVGhlIGNhbGxiYWNrcy5cbiAqIEByZXR1cm4ge1JlYWRhYmxlU3RyZWFtfSBUaGUgQUlTdHJlYW0uXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBPSy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEFJU3RyZWFtKFxuICByZXNwb25zZTogUmVzcG9uc2UsXG4gIGN1c3RvbVBhcnNlcj86IEFJU3RyZWFtUGFyc2VyLFxuICBjYWxsYmFja3M/OiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMsXG4pOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcignUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHknKSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNwb25zZUJvZHlTdHJlYW0gPSByZXNwb25zZS5ib2R5IHx8IGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTtcblxuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSlcbiAgICAucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5cbi8vIG91dHB1dHMgbGluZXMgbGlrZVxuLy8gMDogY2h1bmtcbi8vIDA6IG1vcmUgY2h1bmtcbi8vIDE6IGEgZmN0IGNhbGxcbi8vIHo6IGFkZGVkIGRhdGEgZnJvbSBEYXRhXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBSZWFkYWJsZVN0cmVhbSB0aGF0IGltbWVkaWF0ZWx5IGNsb3NlcyB1cG9uIGNyZWF0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGFzIGEgZmFsbGJhY2sgZm9yIGNyZWF0aW5nIGEgUmVhZGFibGVTdHJlYW0gd2hlbiB0aGUgcmVzcG9uc2UgYm9keSBpcyBudWxsIG9yIHVuZGVmaW5lZCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhlIHN1YnNlcXVlbnQgcGlwZWxpbmUgcHJvY2Vzc2luZyBkb2Vzbid0IGZhaWwgZHVlIHRvIGEgbGFjayBvZiBhIHN0cmVhbS5cbiAqXG4gKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW19IEFuIGVtcHR5IGFuZCBjbG9zZWQgUmVhZGFibGVTdHJlYW0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBSZWFkYWJsZVN0cmVhbS5mcm9tKGFzeW5jSXRlcmFibGUpLCB3aGljaCBpc24ndCBkb2N1bWVudGVkIGluIE1ETiBhbmQgaXNuJ3QgaW1wbGVtZW50ZWQgaW4gbm9kZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvc3RyZWFtcy9jb21taXQvOGQ3YTBiZjI2ZWIyY2MyM2U4ODRkZGJhYWM3YzFkYTRiOTFjZjJiY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZTxUPihpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUPikge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbTxUPih7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZSBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICBhd2FpdCBpdC5yZXR1cm4/LihyZWFzb24pO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgZm9ybWF0U3RyZWFtUGFydCB9IGZyb20gJy4uL3NoYXJlZC9zdHJlYW0tcGFydHMnO1xuaW1wb3J0IHsgSlNPTlZhbHVlIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuLyoqXG4gKiBBIHN0cmVhbSB3cmFwcGVyIHRvIHNlbmQgY3VzdG9tIEpTT04tZW5jb2RlZCBkYXRhIGJhY2sgdG8gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbURhdGEge1xuICBwcml2YXRlIGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICBwcml2YXRlIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFVpbnQ4QXJyYXk+IHwgbnVsbCA9XG4gICAgbnVsbDtcbiAgcHVibGljIHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+O1xuXG4gIC8vIGNsb3NpbmcgdGhlIHN0cmVhbSBpcyBzeW5jaHJvbm91cywgYnV0IHdlIHdhbnQgdG8gcmV0dXJuIGEgcHJvbWlzZVxuICAvLyBpbiBjYXNlIHdlJ3JlIGRvaW5nIGFzeW5jIHdvcmtcbiAgcHJpdmF0ZSBpc0Nsb3NlZFByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0Nsb3NlZFByb21pc2VSZXNvbHZlcjogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIGlzQ2xvc2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gYXJyYXkgdG8gc3RvcmUgYXBwZW5kZWQgZGF0YVxuICBwcml2YXRlIGRhdGE6IEpTT05WYWx1ZVtdID0gW107XG4gIHByaXZhdGUgbWVzc2FnZUFubm90YXRpb25zOiBKU09OVmFsdWVbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBzdGFydDogYXN5bmMgY29udHJvbGxlciA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgLy8gYWRkIGJ1ZmZlcmVkIGRhdGEgdG8gdGhlIHN0cmVhbVxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KCdkYXRhJywgc2VsZi5kYXRhKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZE1lc3NhZ2VBbm5vdGF0aW9ucyA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KCdtZXNzYWdlX2Fubm90YXRpb25zJywgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZE1lc3NhZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgLy8gU2hvdyBhIHdhcm5pbmcgZHVyaW5nIGRldiBpZiB0aGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZyBhZnRlciAzIHNlY29uZHMuXG4gICAgICAgIGNvbnN0IHdhcm5pbmdUaW1lb3V0ID1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xuICAgICAgICAgICAgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/JyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9LCAzMDAwKVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIGF3YWl0IHNlbGYuaXNDbG9zZWRQcm9taXNlO1xuXG4gICAgICAgIGlmICh3YXJuaW5nVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoJ2RhdGEnLCBzZWxmLmRhdGEpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KCdtZXNzYWdlX2Fubm90YXRpb25zJywgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyPy4oKTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGFwcGVuZCh2YWx1ZTogSlNPTlZhbHVlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICB9XG5cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIHRoaXMubWVzc2FnZUFubm90YXRpb25zLnB1c2godmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQSBUcmFuc2Zvcm1TdHJlYW0gZm9yIExMTXMgdGhhdCBkbyBub3QgaGF2ZSB0aGVpciBvd24gdHJhbnNmb3JtIHN0cmVhbSBoYW5kbGVycyBtYW5hZ2luZyBlbmNvZGluZyAoZS5nLiBPcGVuQUlTdHJlYW0gaGFzIG9uZSBmb3IgZnVuY3Rpb24gY2FsbCBoYW5kbGluZykuXG4gKiBUaGlzIGFzc3VtZXMgZXZlcnkgY2h1bmsgaXMgYSAndGV4dCcgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGBTdHJlYW1EYXRhYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgZXh0ZW5kcyBTdHJlYW1EYXRhIHt9XG4iLCJpbXBvcnQgeyBmb3JtYXRTdHJlYW1QYXJ0IH0gZnJvbSAnLi4vc2hhcmVkL3N0cmVhbS1wYXJ0cyc7XG5pbXBvcnQge1xuICBDcmVhdGVNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMnO1xuXG5pbXBvcnQge1xuICBBSVN0cmVhbSxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIsXG4gIHR5cGUgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxuICBGdW5jdGlvbkNhbGxQYXlsb2FkLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgVG9vbENhbGxQYXlsb2FkLFxufSBmcm9tICcuL2FpLXN0cmVhbSc7XG5pbXBvcnQgeyBBenVyZUNoYXRDb21wbGV0aW9ucyB9IGZyb20gJy4vYXp1cmUtb3BlbmFpLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciB9IGZyb20gJy4vc3RyZWFtLWRhdGEnO1xuXG5leHBvcnQgdHlwZSBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTA2MTMnLFxuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICBmdW5jdGlvbnMsXG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbDogYXN5bmMgKGZ1bmN0aW9uQ2FsbFBheWxvYWQsIGNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24oZnVuY3Rpb25DYWxsUGF5bG9hZClcbiAgICpcbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICAgICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgICAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwiZnVuY3Rpb25cIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKHJlc3VsdCldLFxuICAgKiAgICAgICBmdW5jdGlvbnMsXG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgZnVuY3Rpb25DYWxsUGF5bG9hZDogRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgICBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlczogKFxuICAgICAgZnVuY3Rpb25DYWxsUmVzdWx0OiBKU09OVmFsdWUsXG4gICAgKSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICB0b29scyxcbiAgICogICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOiBhc3luYyAodG9vbENhbGxQYXlsb2FkLCBhcHBlbmRUb29sQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgIGxldCBtZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW11cbiAgICogICAgLy8gICBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSB0b29sIGNhbGxzLCBzbyB3ZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtXG4gICAqICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICogICAgIC8vIC4uLiBydW4geW91ciBjdXN0b20gbG9naWMgaGVyZVxuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlGdW5jdGlvbih0b29sLmZ1bmN0aW9uKVxuICAgKiAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwidG9vbFwiIGNhbGwgbWVzc2FnZXNcbiAgICogICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSh7dG9vbF9jYWxsX2lkOnRvb2wuaWQsIGZ1bmN0aW9uX25hbWU6dG9vbC5mdW5jdGlvbi5uYW1lLCB0b29sX2NhbGxfcmVzdWx0OnJlc3VsdH0pXG4gICAqICAgIH1cbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0xMTA2JywgLy8gb3IgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZXN1bHRzIG1lc3NhZ2VzLCBjYWxsaW5nIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSB3aXRob3V0XG4gICAqICAgICAgIC8vIGFueSBhcmd1bWVudHMgd2lsbCBqc3V0IHJldHVybiB0aGUgYWNjdW11bGF0ZWQgbWVzc2FnZXNcbiAgICogICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlcywgLi4uYXBwZW5kVG9vbENhbGxNZXNzYWdlKCldLFxuICAgKiAgICAgICB0b29scyxcbiAgICogICAgICAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gYXV0byBpcyBkZWZhdWx0LCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsPzogKFxuICAgIHRvb2xDYWxsUGF5bG9hZDogVG9vbENhbGxQYXlsb2FkLFxuICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZTogKHJlc3VsdD86IHtcbiAgICAgIHRvb2xfY2FsbF9pZDogc3RyaW5nO1xuICAgICAgZnVuY3Rpb25fbmFtZTogc3RyaW5nO1xuICAgICAgdG9vbF9jYWxsX3Jlc3VsdDogSlNPTlZhbHVlO1xuICAgIH0pID0+IENyZWF0ZU1lc3NhZ2VbXSxcbiAgKSA9PiBQcm9taXNlPFxuICAgIFJlc3BvbnNlIHwgdW5kZWZpbmVkIHwgdm9pZCB8IHN0cmluZyB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICA+O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0wyOC1MNDBcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgaWQ6IHN0cmluZztcbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVua0Nob2ljZT47XG4gIGNyZWF0ZWQ6IG51bWJlcjtcbiAgbW9kZWw6IHN0cmluZztcbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMNDMtTDQ5XG4vLyBVcGRhdGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC9mMTBjNzU3ZDgzMWQ5MDQwN2JhNDdiNDY1OWQ5Y2QzNGIxYTM1YjFkXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rQ2hvaWNlIHtcbiAgZGVsdGE6IENob2ljZURlbHRhO1xuICBmaW5pc2hfcmVhc29uOlxuICAgIHwgJ3N0b3AnXG4gICAgfCAnbGVuZ3RoJ1xuICAgIHwgJ3Rvb2xfY2FsbHMnXG4gICAgfCAnY29udGVudF9maWx0ZXInXG4gICAgfCAnZnVuY3Rpb25fY2FsbCdcbiAgICB8IG51bGw7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMTIzLUwxMzlcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIENob2ljZURlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IEZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJztcblxuICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGFUb29sQ2FsbD47XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIERlbHRhVG9vbENhbGwge1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24/OiBUb29sQ2FsbEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZT86ICdmdW5jdGlvbic7XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIFRvb2xDYWxsRnVuY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvM2VjNDNlZTc5MGEyZWI2YTBjY2RkNWYyNWZhYTIzMjUxYjBmOWI4ZS9zcmMvcmVzb3VyY2VzL2NvbXBsZXRpb25zLnRzI0wyOEMxLUw2NEMxXG4gKiBDb21wbGV0aW9ucyBBUEkuIFN0cmVhbWVkIGFuZCBub24tc3RyZWFtZWQgcmVzcG9uc2VzIGFyZSB0aGUgc2FtZS5cbiAqL1xuaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjb21wbGV0aW9uIGNob2ljZXMgdGhlIG1vZGVsIGdlbmVyYXRlZCBmb3IgdGhlIGlucHV0IHByb21wdC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENvbXBsZXRpb25DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInRleHRfY29tcGxldGlvblwiXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvblVzYWdlO1xufVxuXG5pbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBvciBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZC5cbiAgICovXG4gIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIC8vIGVkaXRlZDogUmVtb3ZlZCBDb21wbGV0aW9uQ2hvaWNlLmxvZ1Byb2JzIGFuZCByZXBsYWNlZCB3aXRoIGFueVxuICBsb2dwcm9iczogYW55IHwgbnVsbDtcblxuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgdGhlIE9wZW5BSSBzdHJlYW0gZGF0YS5cbiAqIFRoZSBwYXJzZXIgZXh0cmFjdHMgYW5kIHRyaW1zIHRleHQgY29udGVudCBmcm9tIHRoZSBKU09OIGRhdGEuIFRoaXMgcGFyc2VyXG4gKiBjYW4gaGFuZGxlIGRhdGEgZm9yIGNoYXQgb3IgY29tcGxldGlvbiBtb2RlbHMuXG4gKlxuICogQHJldHVybiB7KGRhdGE6IHN0cmluZykgPT4gc3RyaW5nIHwgdm9pZHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfX1cbiAqIEEgcGFyc2VyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBKU09OIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyB0aGUgZXh0cmFjdGVkIHRleHQgY29udGVudCxcbiAqIGEgY29tcGxleCBvYmplY3Qgd2l0aCBpc1RleHQ6IGZhbHNlIGZvciBmdW5jdGlvbi90b29sIGNhbGxzLCBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpOiAoXG4gIGRhdGE6IHN0cmluZyxcbikgPT4gc3RyaW5nIHwgdm9pZCB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0ge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIGRhdGEgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpIGFzIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTtcbn1cblxuLyoqXG4gKiBSZWFkcyBjaHVua3MgZnJvbSBPcGVuQUkncyBuZXcgU3RyZWFtYWJsZSBpbnRlcmZhY2UsIHdoaWNoIGlzIGVzc2VudGlhbGx5XG4gKiB0aGUgc2FtZSBhcyB0aGUgb2xkIFJlc3BvbnNlIGJvZHkgaW50ZXJmYWNlIHdpdGggYW4gaW5jbHVkZWQgU1NFIHBhcnNlclxuICogZG9pbmcgdGhlIHBhcnNpbmcgZm9yIHVzLlxuICovXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW06IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcykge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcblxuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAvLyBjb252ZXJ0IGNodW5rIGlmIGl0IGlzIGFuIEF6dXJlIGNoYXQgY29tcGxldGlvbi4gQXp1cmUgZG9lcyBub3QgZXhwb3NlIGFsbFxuICAgIC8vIHByb3BlcnRpZXMgaW4gdGhlIGludGVyZmFjZXMsIGFuZCBhbHNvIHVzZXMgY2FtZWxDYXNlIGluc3RlYWQgb2Ygc25ha2VfY2FzZVxuICAgIGlmICgncHJvbXB0RmlsdGVyUmVzdWx0cycgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IChjaHVuayBhcyBhbnkpLm9iamVjdCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiAoY2h1bmsgYXMgYW55KS5tb2RlbCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKGNob2ljZSA9PiAoe1xuICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICBjb250ZW50OiBjaG9pY2UuZGVsdGE/LmNvbnRlbnQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaG9pY2UuZGVsdGE/LmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgIHJvbGU6IGNob2ljZS5kZWx0YT8ucm9sZSBhcyBhbnksXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBjaG9pY2UuZGVsdGE/LnRvb2xDYWxscz8ubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24gYXMgYW55LFxuICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXgsXG4gICAgICAgIH0pKSxcbiAgICAgIH0gc2F0aXNmaWVzIENoYXRDb21wbGV0aW9uQ2h1bms7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuXG4gICAgaWYgKHRleHQpIHlpZWxkIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKTogKFxuICBjaHVuazogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pID0+IHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0gfCB2b2lkIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luOiBib29sZWFuO1xuICByZXR1cm4ganNvbiA9PiB7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhO1xuICAgICAgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/Lm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7dG9vbENhbGwuZnVuY3Rpb24/Lm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/LmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cyhkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAoanNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnZnVuY3Rpb25fY2FsbCcgfHxcbiAgICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICdzdG9wJylcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19JyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICd0b29sX2NhbGxzJ1xuICAgICAgKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfScsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnRcbiAgICAgICAgOiBpc0NvbXBsZXRpb24oanNvbilcbiAgICAgICAgPyBqc29uLmNob2ljZXNbMF0udGV4dFxuICAgICAgICA6ICcnLFxuICAgICk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bms6IHN0cmluZykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAvLyBSZXBsYWNlIGJhY2tzbGFzaGVzIGZpcnN0IHRvIHByZXZlbnQgZG91YmxlIGVzY2FwaW5nXG4gICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcLycpIC8vIEVzY2FwZSBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIC8vIEVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIC8vIEVzY2FwZSBuZXcgbGluZXNcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgLy8gRXNjYXBlIGNhcnJpYWdlIHJldHVybnNcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgLy8gRXNjYXBlIHRhYnNcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJyk7IC8vIEVzY2FwZSBmb3JtIGZlZWRzXG5cbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cblxuY29uc3QgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgJ2ludGVybmFsX29wZW5haV9mbl9tZXNzYWdlcycsXG4pO1xuXG50eXBlIEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIHwgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxuICB8IEFzeW5jSXRlcmFibGU8Q29tcGxldGlvbj5cbiAgfCBBc3luY0l0ZXJhYmxlPEF6dXJlQ2hhdENvbXBsZXRpb25zPjtcblxudHlwZSBFeHRyYWN0VHlwZTxUPiA9IFQgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGluZmVyIFU+ID8gVSA6IG5ldmVyO1xuXG50eXBlIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzID1cbiAgRXh0cmFjdFR5cGU8QXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzPjtcblxuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKFxuICBkYXRhOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbik6IGRhdGEgaXMgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIHJldHVybiAoXG4gICAgJ2Nob2ljZXMnIGluIGRhdGEgJiZcbiAgICBkYXRhLmNob2ljZXMgJiZcbiAgICBkYXRhLmNob2ljZXNbMF0gJiZcbiAgICAnZGVsdGEnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpOiBkYXRhIGlzIENvbXBsZXRpb24ge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ3RleHQnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlbkFJU3RyZWFtKFxuICByZXM6IFJlc3BvbnNlIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzLFxuICBjYWxsYmFja3M/OiBPcGVuQUlTdHJlYW1DYWxsYmFja3MsXG4pOiBSZWFkYWJsZVN0cmVhbSB7XG4gIC8vIEFubm90YXRlIHRoZSBpbnRlcm5hbCBgbWVzc2FnZXNgIHByb3BlcnR5IGZvciByZWN1cnNpdmUgZnVuY3Rpb24gY2FsbHNcbiAgY29uc3QgY2I6XG4gICAgfCB1bmRlZmluZWRcbiAgICB8IChPcGVuQUlTdHJlYW1DYWxsYmFja3MgJiB7XG4gICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXT86IENyZWF0ZU1lc3NhZ2VbXTtcbiAgICAgIH0pID0gY2FsbGJhY2tzO1xuXG4gIGxldCBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+O1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIGNiPy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2I/LmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgICAgICBvbkZpbmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICBjYj8uZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiPy5leHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgICAgb25GaW5hbDogdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICB9LFxuICAgICk7XG4gIH1cblxuICBpZiAoY2IgJiYgKGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICBjb25zdCBmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNiKTtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihcbiAgY2FsbGJhY2tzOiBPcGVuQUlTdHJlYW1DYWxsYmFja3MgJiB7XG4gICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdPzogQ3JlYXRlTWVzc2FnZVtdO1xuICB9LFxuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSAnJztcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9ICcnO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG5cbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzOiBDcmVhdGVNZXNzYWdlW10gPVxuICAgIGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcblxuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuXG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID1cbiAgICAgICAgaXNGaXJzdENodW5rICYmXG4gICAgICAgIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fFxuICAgICAgICAgIG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKTtcblxuICAgICAgaWYgKHNob3VsZEhhbmRsZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN0cmVhbSBhcyBub3JtYWxcbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWlzRmlyc3RDaHVuayAmJlxuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAgIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8XG4gICAgICAgICAgICBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpXG4gICAgICAgICkge1xuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIG1lc3NhZ2UgdG8gdGhlIGxpc3RcbiAgICAgICAgICBsZXQgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM6IENyZWF0ZU1lc3NhZ2VbXSA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgIF07XG5cbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZTpcbiAgICAgICAgICAgIHwgUmVzcG9uc2VcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgICAgICB8IHZvaWRcbiAgICAgICAgICAgIHwgc3RyaW5nXG4gICAgICAgICAgICB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICAgICAgICAgICAgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgLy8gVGhpcyBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIGNoZWNrIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IGJ1dCBUUyBjb21wbGFpbnNcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgdXNpbmcgdGhlIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBjYWxsYmFjaywgdGhleSBzaG91bGQgbm90IGJlIHVzaW5nIHRvb2xzXG4gICAgICAgICAgICAvLyBpZiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgaXMgbm90IGRlZmluZWQgYnkgdGltZSB3ZSBnZXQgaGVyZSB3ZSBtdXN0IGhhdmUgZ290dGVuIGEgdG9vbCByZXNwb25zZVxuICAgICAgICAgICAgLy8gYW5kIHRoZSB1c2VyIGhhZCBkZWZpbmVkIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mdW5jdGlvbl9jYWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXF1ZXN0IGFuZCByZXN1bHQgbWVzc2FnZXMgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBheWxvYWQuZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBpdCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsczogVG9vbENhbGxQYXlsb2FkID0ge1xuICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHBheWxvYWQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMudG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRvb2wuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBmdW5jOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04ucGFyc2UodG9vbC5mdW5jdGlvbi5hcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbChcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sX2NhbGxfaWQsIGZ1bmN0aW9uX25hbWUsIHRvb2xfY2FsbF9yZXN1bHQgfSA9XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVxdWVzdCBhbmQgcmVzdWx0IG1lc3NhZ2VzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpZiBpdCdzIHRoZSBmaXJzdCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgIC4uLihyZXNwb25zZUluZGV4ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyBhcyBjb25zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsczogcGF5bG9hZC50b29sX2NhbGxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRjOiBUb29sQ2FsbCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyBhbiBvYmplY3QgdG8gdGhlIHVzZXIsIGJ1dCBhcyB0aGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcsIHdlIG5lZWQgdG8gc3RyaW5naWZ5IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Yy5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVzdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndG9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX3Jlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGl0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsbGluZyBleHBlcmltZW50YWxfb25Ub29sQ2FsbDonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGRpZG4ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSBmdW5jdGlvbiBjYWxsIG9uIHRoZSBzZXJ2ZXIgYW5kIHdhbnRzXG4gICAgICAgICAgICAvLyB0byBlaXRoZXIgZG8gbm90aGluZyBvciBydW4gaXQgb24gdGhlIGNsaWVudFxuICAgICAgICAgICAgLy8gc28gd2UganVzdCByZXR1cm4gdGhlIGZ1bmN0aW9uIGNhbGwgYXMgYSBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gJ2Z1bmN0aW9uX2NhbGwnIDogJ3Rvb2xfY2FsbHMnLFxuICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdG8gcHJldmVudCBkb3VibGUtZW5jb2Rpbmc6XG4gICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIHJldHVybmVkIGEgc3RyaW5nLCBzbyB3ZSBqdXN0IHJldHVybiBpdCBhcyBhIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBmdW5jdGlvblJlc3BvbnNlKSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gZnVuY3Rpb25SZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseTpcblxuICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBvblN0YXJ0IG9yIG9uQ29tcGxldGUgcmVjdXJzaXZlbHlcbiAgICAgICAgICAvLyBzbyB3ZSByZW1vdmUgdGhlbSBmcm9tIHRoZSBjYWxsYmFja3NcbiAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9haS9pc3N1ZXMvMzUxXG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRDYWxsYmFja3M6IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uU3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCBvbkZpbmFsIHRvIGJlIGNhbGxlZCB0aGUgX2xhc3RfIHRpbWVcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGNvbnN0IG9wZW5BSVN0cmVhbSA9IE9wZW5BSVN0cmVhbShmdW5jdGlvblJlc3BvbnNlLCB7XG4gICAgICAgICAgICAuLi5maWx0ZXJlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXTogbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgfSBhcyBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMpO1xuXG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuIiwiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcbmV4cG9ydCBjb25zdCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSA9IDE1ICogMTAwMDtcbiIsImltcG9ydCB7XG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIExhbmd1YWdlTW9kZWxWMSxcbiAgTm9TdWNoVG9vbEVycm9yLFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuXG5pbXBvcnQgeyBDYWxsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9jYWxsLXNldHRpbmdzJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3Byb21wdCc7XG5pbXBvcnQgeyBjcmVhdGVTdHJlYW1hYmxlVUkgfSBmcm9tICcuLi9zdHJlYW1hYmxlJztcbmltcG9ydCB7IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYnO1xuaW1wb3J0IHsgZ2V0VmFsaWRhdGVkUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQnO1xuaW1wb3J0IHsgY29udmVydFpvZFRvSlNPTlNjaGVtYSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9jb252ZXJ0LXpvZC10by1qc29uLXNjaGVtYSc7XG5pbXBvcnQgeyBwcmVwYXJlQ2FsbFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzJztcbmltcG9ydCB7IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdCc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xuXG50eXBlIFJlbmRlcmVyPFQgZXh0ZW5kcyBBcnJheTxhbnk+PiA9IChcbiAgLi4uYXJnczogVFxuKSA9PlxuICB8IFN0cmVhbWFibGVcbiAgfCBHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD5cbiAgfCBBc3luY0dlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPjtcblxudHlwZSBSZW5kZXJUb29sPFBBUkFNRVRFUlMgZXh0ZW5kcyB6LlpvZFR5cGVBbnkgPSBhbnk+ID0ge1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgcGFyYW1ldGVyczogUEFSQU1FVEVSUztcbiAgZ2VuZXJhdGU/OiBSZW5kZXJlcjxcbiAgICBbXG4gICAgICB6LmluZmVyPFBBUkFNRVRFUlM+LFxuICAgICAge1xuICAgICAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgICAgICB0b29sQ2FsbElkOiBzdHJpbmc7XG4gICAgICB9LFxuICAgIF1cbiAgPjtcbn07XG5cbnR5cGUgUmVuZGVyVGV4dCA9IFJlbmRlcmVyPFxuICBbXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc28gZmFyLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuZXcgYXBwZW5kZWQgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNpbmNlIHRoZSBsYXN0IGB0ZXh0YCBjYWxsLlxuICAgICAgICovXG4gICAgICBkZWx0YTogc3RyaW5nO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgICAqIElmIGB0cnVlYCwgdGhlIGBjb250ZW50YCB3aWxsIGJlIHRoZSBmaW5hbCBvdXRwdXQgYW5kIHRoaXMgY2FsbCB3aWxsIGJlIHRoZSBsYXN0LlxuICAgICAgICovXG4gICAgICBkb25lOiBib29sZWFuO1xuICAgIH0sXG4gIF1cbj47XG5cbnR5cGUgUmVuZGVyUmVzdWx0ID0ge1xuICB2YWx1ZTogUmVhY3ROb2RlO1xufSAmIEF3YWl0ZWQ8UmV0dXJuVHlwZTxMYW5ndWFnZU1vZGVsVjFbJ2RvU3RyZWFtJ10+PjtcblxuY29uc3QgZGVmYXVsdFRleHRSZW5kZXJlcjogUmVuZGVyVGV4dCA9ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT5cbiAgY29udGVudDtcblxuLyoqXG4gKiBgc3RyZWFtVUlgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBMTE1zLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVUk8XG4gIFRPT0xTIGV4dGVuZHMgeyBbbmFtZTogc3RyaW5nXTogei5ab2RUeXBlQW55IH0gPSB7fSxcbj4oe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGluaXRpYWwsXG4gIHRleHQsXG4gIC4uLnNldHRpbmdzXG59OiBDYWxsU2V0dGluZ3MgJlxuICBQcm9tcHQgJiB7XG4gICAgLyoqXG4gICAgICogVGhlIGxhbmd1YWdlIG1vZGVsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBtb2RlbDogTGFuZ3VhZ2VNb2RlbFYxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRoYXQgdGhlIG1vZGVsIGNhbiBjYWxsLiBUaGUgbW9kZWwgbmVlZHMgdG8gc3VwcG9ydCBjYWxsaW5nIHRvb2xzLlxuICAgICAqL1xuICAgIHRvb2xzPzoge1xuICAgICAgW25hbWUgaW4ga2V5b2YgVE9PTFNdOiBSZW5kZXJUb29sPFRPT0xTW25hbWVdPjtcbiAgICB9O1xuXG4gICAgdGV4dD86IFJlbmRlclRleHQ7XG4gICAgaW5pdGlhbD86IFJlYWN0Tm9kZTtcbiAgfSk6IFByb21pc2U8UmVuZGVyUmVzdWx0PiB7XG4gIC8vIFRPRE86IFJlbW92ZSB0aGVzZSBlcnJvcnMgYWZ0ZXIgdGhlIGV4cGVyaW1lbnRhbCBwaGFzZS5cbiAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYG1vZGVsYCBjYW5ub3QgYmUgYSBzdHJpbmcgaW4gYHN0cmVhbVVJYC4gVXNlIHRoZSBhY3R1YWwgbW9kZWwgaW5zdGFuY2UgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdmdW5jdGlvbnMnIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2BmdW5jdGlvbnNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYHN0cmVhbVVJYCwgdXNlIGB0b29sc2AgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdwcm92aWRlcicgaW4gc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYHByb3ZpZGVyYCBpcyBubyBsb25nZXIgbmVlZGVkIGluIGBzdHJlYW1VSWAuIFVzZSBgbW9kZWxgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIE9iamVjdC5lbnRyaWVzKHRvb2xzKSkge1xuICAgICAgaWYgKCdyZW5kZXInIGluIHRvb2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUb29sIGRlZmluaXRpb24gaW4gYHN0cmVhbVVJYCBzaG91bGQgbm90IGhhdmUgYHJlbmRlcmAgcHJvcGVydHkuIFVzZSBgZ2VuZXJhdGVgIGluc3RlYWQuIEZvdW5kIGluIHRvb2w6ICcgK1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsKTtcblxuICAvLyBUaGUgZGVmYXVsdCB0ZXh0IHJlbmRlcmVyIGp1c3QgcmV0dXJucyB0aGUgY29udGVudCBhcyBzdHJpbmcuXG4gIGNvbnN0IHRleHRSZW5kZXIgPSB0ZXh0IHx8IGRlZmF1bHRUZXh0UmVuZGVyZXI7XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihcbiAgICBhcmdzOiBbcGF5bG9hZDogYW55XSB8IFtwYXlsb2FkOiBhbnksIG9wdGlvbnM6IGFueV0sXG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT4sXG4gICAgcmVzOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+LFxuICApIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoLi4uYXJncyk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgKHZhbHVlIGFzIFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPik7XG4gICAgICByZXMudXBkYXRlKG5vZGUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICAgICkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBBc3luY0dlbmVyYXRvcjxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIHZvaWRcbiAgICAgID47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEdlbmVyYXRvcjxSZWFjdC5SZWFjdE5vZGUsIFJlYWN0LlJlYWN0Tm9kZSwgdm9pZD47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT5cbiAgICBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICBtb2RlOiB7XG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyxcbiAgICAgICAgdG9vbHM6XG4gICAgICAgICAgdG9vbHMgPT0gbnVsbFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2xdKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHRvb2wucGFyYW1ldGVycyksXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgIH0sXG4gICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgfSksXG4gICk7XG5cbiAgY29uc3QgW3N0cmVhbSwgZm9ya2VkU3RyZWFtXSA9IHJlc3VsdC5zdHJlYW0udGVlKCk7XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uc3VtZSB0aGUgZm9ya2VkIHN0cmVhbSBhc3luY2hvbm91c2x5LlxuXG4gICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgbGV0IGhhc1Rvb2xDYWxsID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IHJlYWRlciA9IGZvcmtlZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcblxuICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0ZXh0LWRlbHRhJzoge1xuICAgICAgICAgICAgY29udGVudCArPSB2YWx1ZS50ZXh0RGVsdGE7XG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgIFt7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogdmFsdWUudGV4dERlbHRhIH1dLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVyLFxuICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwtZGVsdGEnOiB7XG4gICAgICAgICAgICBoYXNUb29sQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwnOiB7XG4gICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHZhbHVlLnRvb2xOYW1lIGFzIGtleW9mIFRPT0xTICYgc3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbE5hbWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRvb2wpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgIHNjaGVtYTogdG9vbC5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgdG9vbEFyZ3M6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIHRvb2wuZ2VuZXJhdGUsXG4gICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICB0aHJvdyB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmaW5pc2gnOiB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNUb29sQ2FsbCkge1xuICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVuZGVyKFt7IGNvbnRlbnQsIGRvbmU6IHRydWUgfV0sIHRleHRSZW5kZXIsIHVpKTtcbiAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgIHVpLmRvbmUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRHVyaW5nIHRoZSBzdHJlYW0gcmVuZGVyaW5nLCB3ZSBkb24ndCB3YW50IHRvIHRocm93IHRoZSBlcnJvciB0byB0aGVcbiAgICAgIC8vIHBhcmVudCBzY29wZSBidXQgb25seSBsZXQgdGhlIFJlYWN0J3MgZXJyb3IgYm91bmRhcnkgdG8gY2F0Y2ggaXQuXG4gICAgICB1aS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzdWx0LFxuICAgIHN0cmVhbSxcbiAgICB2YWx1ZTogdWkudmFsdWUsXG4gIH07XG59XG4iLCIvLyBUaGlzIGZpbGUgcHJvdmlkZXMgdGhlIEFJIGNvbnRleHQgdG8gYWxsIEFJIEFjdGlvbnMgdmlhIEFzeW5jTG9jYWxTdG9yYWdlLlxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJbnRlcm5hbEFJUHJvdmlkZXIgfSBmcm9tICcuL3JzYy1zaGFyZWQubWpzJztcbmltcG9ydCB7XG4gIHdpdGhBSVN0YXRlLFxuICBnZXRBSVN0YXRlRGVsdGFQcm9taXNlLFxuICBzZWFsTXV0YWJsZUFJU3RhdGUsXG59IGZyb20gJy4vYWktc3RhdGUnO1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyxcbiAgQUlBY3Rpb24sXG4gIEFJQWN0aW9ucyxcbiAgQUlQcm92aWRlcixcbiAgSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4gIE9uU2V0QUlTdGF0ZSxcbiAgT25HZXRVSVN0YXRlLFxufSBmcm9tICcuL3R5cGVzJztcblxuYXN5bmMgZnVuY3Rpb24gaW5uZXJBY3Rpb248VD4oXG4gIHtcbiAgICBhY3Rpb24sXG4gICAgb3B0aW9ucyxcbiAgfTogeyBhY3Rpb246IEFJQWN0aW9uOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBzdGF0ZTogVCxcbiAgLi4uYXJnczogdW5rbm93bltdXG4pIHtcbiAgJ3VzZSBzZXJ2ZXInO1xuICByZXR1cm4gYXdhaXQgd2l0aEFJU3RhdGUoXG4gICAge1xuICAgICAgc3RhdGUsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgc2VhbE11dGFibGVBSVN0YXRlKCk7XG4gICAgICByZXR1cm4gW2dldEFJU3RhdGVEZWx0YVByb21pc2UoKSBhcyBQcm9taXNlPFQ+LCByZXN1bHRdO1xuICAgIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb248VCA9IHVua25vd24+KFxuICBhY3Rpb246IEFJQWN0aW9uLFxuICBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbikge1xuICByZXR1cm4gaW5uZXJBY3Rpb24uYmluZChudWxsLCB7IGFjdGlvbiwgb3B0aW9ucyB9KSBhcyBBSUFjdGlvbjxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFJPFxuICBBSVN0YXRlID0gYW55LFxuICBVSVN0YXRlID0gYW55LFxuICBBY3Rpb25zIGV4dGVuZHMgQUlBY3Rpb25zID0ge30sXG4+KHtcbiAgYWN0aW9ucyxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxVSVN0YXRlLFxuXG4gIG9uU2V0QUlTdGF0ZSxcbiAgb25HZXRVSVN0YXRlLFxufToge1xuICBhY3Rpb25zOiBBY3Rpb25zO1xuICBpbml0aWFsQUlTdGF0ZT86IEFJU3RhdGU7XG4gIGluaXRpYWxVSVN0YXRlPzogVUlTdGF0ZTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIEFJIHN0YXRlIGlzIHVwZGF0ZWQgYnkgYW4gQWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRvIHBlcnNpc3QgdGhlIEFJIHN0YXRlIHRvIGEgZGF0YWJhc2UsIG9yIHRvIHNlbmQgaXQgdG8gYVxuICAgKiBsb2dnaW5nIHNlcnZpY2UuXG4gICAqL1xuICBvblNldEFJU3RhdGU/OiBPblNldEFJU3RhdGU8QUlTdGF0ZT47XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgVUkgc3RhdGUgYmFzZWQgb24gdGhlIEFJIHN0YXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gcmVuZGVyIHRoZSBpbml0aWFsIFVJIHN0YXRlIGJhc2VkIG9uIGEgZ2l2ZW4gQUkgc3RhdGUsIG9yXG4gICAqIHRvIHN5bmMgdGhlIFVJIHN0YXRlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIGFscmVhZHkgbG9hZGVkLlxuICAgKlxuICAgKiBJZiByZXR1cm5pbmcgYHVuZGVmaW5lZGAsIHRoZSBjbGllbnQgc2lkZSBVSSBzdGF0ZSB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgYW5ub3RhdGVkIHdpdGggdGhlIGBcInVzZSBzZXJ2ZXJcImAgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogb25HZXRVSVN0YXRlOiBhc3luYyAoKSA9PiB7XG4gICAqICAgJ3VzZSBzZXJ2ZXInO1xuICAgKlxuICAgKiAgIGNvbnN0IGN1cnJlbnRBSVN0YXRlID0gZ2V0QUlTdGF0ZSgpO1xuICAgKiAgIGNvbnN0IGV4dGVybmFsQUlTdGF0ZSA9IGF3YWl0IGxvYWRBSVN0YXRlRnJvbURhdGFiYXNlKCk7XG4gICAqXG4gICAqICAgaWYgKGN1cnJlbnRBSVN0YXRlID09PSBleHRlcm5hbEFJU3RhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAqXG4gICAqICAgLy8gVXBkYXRlIGN1cnJlbnQgQUkgc3RhdGUgYW5kIHJldHVybiB0aGUgbmV3IFVJIHN0YXRlXG4gICAqICAgY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gICAqICAgc3RhdGUuZG9uZShleHRlcm5hbEFJU3RhdGUpXG4gICAqXG4gICAqICAgcmV0dXJuIDxkaXY+Li4uPC9kaXY+O1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb25HZXRVSVN0YXRlPzogT25HZXRVSVN0YXRlPFVJU3RhdGU+O1xufSkge1xuICAvLyBXcmFwIGFsbCBhY3Rpb25zIHdpdGggb3VyIEhvQy5cbiAgY29uc3Qgd3JhcHBlZEFjdGlvbnM6IFNlcnZlcldyYXBwZWRBY3Rpb25zID0ge307XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgd3JhcHBlZEFjdGlvbnNbbmFtZV0gPSB3cmFwQWN0aW9uKGFjdGlvbnNbbmFtZV0sIHtcbiAgICAgIG9uU2V0QUlTdGF0ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHdyYXBwZWRTeW5jVUlTdGF0ZSA9IG9uR2V0VUlTdGF0ZVxuICAgID8gd3JhcEFjdGlvbihvbkdldFVJU3RhdGUsIHt9KVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IEFJOiBBSVByb3ZpZGVyPEFJU3RhdGUsIFVJU3RhdGUsIEFjdGlvbnM+ID0gYXN5bmMgcHJvcHMgPT4ge1xuICAgIGlmICgndXNlU3RhdGUnIGluIFJlYWN0KSB7XG4gICAgICAvLyBUaGlzIGZpbGUgbXVzdCBiZSBydW5uaW5nIG9uIHRoZSBSZWFjdCBTZXJ2ZXIgbGF5ZXIuXG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCBiZSB1c2luZyBgaW1wb3J0IFwic2VydmVyLW9ubHlcImAgaGVyZSBidXQgd2UgY2FuIGhhdmUgYVxuICAgICAgLy8gbW9yZSBjdXN0b21pemVkIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgU2VydmVyIENvbXBvbmVudHMuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHVpU3RhdGUgPSBwcm9wcy5pbml0aWFsVUlTdGF0ZSA/PyBpbml0aWFsVUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZSA9IHByb3BzLmluaXRpYWxBSVN0YXRlID8/IGluaXRpYWxBSVN0YXRlO1xuICAgIGxldCBhaVN0YXRlRGVsdGEgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAod3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICBjb25zdCBbbmV3QUlTdGF0ZURlbHRhLCBuZXdVSVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZShhaVN0YXRlKTtcbiAgICAgIGlmIChuZXdVSVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWlTdGF0ZURlbHRhID0gbmV3QUlTdGF0ZURlbHRhO1xuICAgICAgICB1aVN0YXRlID0gbmV3VUlTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEludGVybmFsQUlQcm92aWRlclxuICAgICAgICB3cmFwcGVkQWN0aW9ucz17d3JhcHBlZEFjdGlvbnN9XG4gICAgICAgIHdyYXBwZWRTeW5jVUlTdGF0ZT17d3JhcHBlZFN5bmNVSVN0YXRlfVxuICAgICAgICBpbml0aWFsVUlTdGF0ZT17dWlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbEFJU3RhdGU9e2FpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlUGF0Y2g9e2FpU3RhdGVEZWx0YX1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9JbnRlcm5hbEFJUHJvdmlkZXI+XG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gQUk7XG59XG4iXSwibmFtZXMiOlsiQXN5bmNMb2NhbFN0b3JhZ2UiLCJqc29uZGlmZnBhdGNoIiwiU3VzcGVuc2UiLCJGcmFnbWVudCIsImpzeCIsImpzeHMiLCJjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsIlIiLCJjIiwibiIsImNodW5rIiwiZG9uZSIsInZhbHVlIiwiYXBwZW5kIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsIm5leHQiLCJjcmVhdGVTdXNwZW5zZWRDaHVuayIsImluaXRpYWxWYWx1ZSIsInJvdyIsImlzRnVuY3Rpb24iLCJ4IiwiY29uc3VtZVN0cmVhbSIsInN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsInJlYWQiLCJhc3luY0FJU3RhdGVTdG9yYWdlIiwiZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyIsIm1lc3NhZ2UiLCJzdG9yZSIsImdldFN0b3JlIiwiRXJyb3IiLCJ3aXRoQUlTdGF0ZSIsInN0YXRlIiwib3B0aW9ucyIsImZuIiwicnVuIiwiY3VycmVudFN0YXRlIiwib3JpZ2luYWxTdGF0ZSIsInNlYWxlZCIsImdldEFJU3RhdGVEZWx0YVByb21pc2UiLCJtdXRhdGlvbkRlbHRhUHJvbWlzZSIsInNlYWxNdXRhYmxlQUlTdGF0ZSIsImdldEFJU3RhdGUiLCJhcmdzIiwibGVuZ3RoIiwia2V5IiwiU3RyaW5nIiwiZ2V0TXV0YWJsZUFJU3RhdGUiLCJtdXRhdGlvbkRlbHRhUmVzb2x2ZSIsImRvVXBkYXRlIiwibmV3U3RhdGUiLCJfYSIsIl9iIiwib25TZXRBSVN0YXRlIiwiY2FsbCIsIm11dGFibGVTdGF0ZSIsImdldCIsInVwZGF0ZSIsIm5ld0FJU3RhdGUiLCJkb25lQXJncyIsImRlbHRhIiwiZGlmZiIsInpvZFRvSnNvblNjaGVtYSIsIkFQSUNhbGxFcnJvciIsIlJldHJ5RXJyb3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJpc0Fib3J0RXJyb3IiLCJkZWxheSIsImRlbGF5SW5NcyIsInNldFRpbWVvdXQiLCJyZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJtYXhSZXRyaWVzIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9ycyIsImVycm9yIiwiZXJyb3JNZXNzYWdlIiwibmV3RXJyb3JzIiwidHJ5TnVtYmVyIiwicmVhc29uIiwiaXNBUElDYWxsRXJyb3IiLCJpc1JldHJ5YWJsZSIsIm1pbWVUeXBlU2lnbmF0dXJlcyIsIm1pbWVUeXBlIiwiYnl0ZXMiLCJkZXRlY3RJbWFnZU1pbWVUeXBlIiwiaW1hZ2UiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJjb250ZW50IiwiVWludDhBcnJheSIsImNhdXNlIiwiQXJyYXlCdWZmZXIiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IiwicHJvbXB0IiwibGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzIiwic3lzdGVtIiwicHVzaCIsInJvbGUiLCJ0eXBlIiwidGV4dCIsIm1lc3NhZ2VzIiwibWFwIiwicGFydCIsIlVSTCIsImltYWdlVWludDgiLCJfZXhoYXVzdGl2ZUNoZWNrIiwiSW52YWxpZFByb21wdEVycm9yIiwiZ2V0VmFsaWRhdGVkUHJvbXB0IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJwcmVwYXJlQ2FsbFNldHRpbmdzIiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJ0b3BQIiwicHJlc2VuY2VQZW5hbHR5IiwiZnJlcXVlbmN5UGVuYWx0eSIsInNlZWQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJwYXJhbWV0ZXIiLCJjb252ZXJ0Wm9kVG9KU09OU2NoZW1hIiwiem9kU2NoZW1hIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwiZnVuY3Rpb25DYWxsU3RyZWFtUGFydCIsImZ1bmN0aW9uX2NhbGwiLCJhcmd1bWVudHMiLCJkYXRhU3RyZWFtUGFydCIsIkFycmF5IiwiaXNBcnJheSIsImVycm9yU3RyZWFtUGFydCIsImFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0IiwiaWQiLCJpdGVtIiwiYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0IiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJkYXRhTWVzc2FnZVN0cmVhbVBhcnQiLCJ0b29sQ2FsbHNTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtUGFydCIsInRvb2xDYWxsSWQiLCJ0b29sTmFtZSIsInRvb2xSZXN1bHRTdHJlYW1QYXJ0Iiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsInBhcnNlU3RyZWFtUGFydCIsImxpbmUiLCJmaXJzdFNlcGFyYXRvckluZGV4IiwiaW5kZXhPZiIsInByZWZpeCIsInNsaWNlIiwiaW5jbHVkZXMiLCJ0ZXh0VmFsdWUiLCJqc29uVmFsdWUiLCJKU09OIiwiZm9ybWF0U3RyZWFtUGFydCIsInN0cmVhbVBhcnQiLCJmaW5kIiwic3RyaW5naWZ5IiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImRlY29kZWQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJjcmVhdGVQYXJzZXIiLCJjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyIiwiY3VzdG9tUGFyc2VyIiwidGV4dERlY29kZXIiLCJldmVudFNvdXJjZVBhcnNlciIsIlRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImV2ZW50IiwiZGF0YSIsInRlcm1pbmF0ZSIsInBhcnNlZE1lc3NhZ2UiLCJlbnF1ZXVlIiwidHJhbnNmb3JtIiwiZmVlZCIsImNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyIiwiY2IiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tzIiwib25TdGFydCIsImVuY29kZSIsIm9uVG9rZW4iLCJvblRleHQiLCJmbHVzaCIsImlzT3BlbkFJQ2FsbGJhY2tzIiwiaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MiLCJvbkNvbXBsZXRpb24iLCJvbkZpbmFsIiwidHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIiLCJpc1N0cmVhbVN0YXJ0IiwidHJpbVN0YXJ0IiwiQUlTdHJlYW0iLCJyZXNwb25zZSIsIm9rIiwiYm9keSIsIlJlYWRhYmxlU3RyZWFtIiwiZXJyb3JUZXh0IiwicmVzcG9uc2VCb2R5U3RyZWFtIiwiY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSIsInBpcGVUaHJvdWdoIiwiY2xvc2UiLCJyZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlIiwiaXRlcmFibGUiLCJpdCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJwdWxsIiwiY2FuY2VsIiwicmV0dXJuIiwiY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyIiwiZW5jb2RlciIsInBhcnNlT3BlbkFJU3RyZWFtIiwiZXh0cmFjdCIsImNodW5rVG9UZXh0Iiwic3RyZWFtYWJsZSIsImNyZWF0ZWQiLCJnZXREYXRlIiwib2JqZWN0IiwibW9kZWwiLCJjaG9pY2VzIiwiY2hvaWNlIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsImZ1bmN0aW9uQ2FsbCIsInRvb2xDYWxscyIsInRvb2xDYWxsIiwiZmluaXNoX3JlYXNvbiIsImZpbmlzaFJlYXNvbiIsInRyaW1TdGFydE9mU3RyZWFtIiwiaXNGdW5jdGlvblN0cmVhbWluZ0luIiwianNvbiIsIl9oIiwiX2kiLCJfaiIsIl9rIiwiX2wiLCJfbSIsIl9uIiwiX28iLCJfcCIsIl9xIiwiX3IiLCJpc0NoYXRDb21wbGV0aW9uQ2h1bmsiLCJpc1RleHQiLCJjbGVhbnVwQXJndW1lbnRzIiwiaXNDb21wbGV0aW9uIiwiYXJndW1lbnRDaHVuayIsImVzY2FwZWRQYXJ0aWFsSnNvbiIsInJlcGxhY2UiLCJfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sIiwiT3BlbkFJU3RyZWFtIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiaXNGaXJzdENodW5rIiwiYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJzaG91bGRIYW5kbGVBc0Z1bmN0aW9uIiwic3RhcnRzV2l0aCIsInBheWxvYWQiLCJuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJjb25zb2xlIiwid2FybiIsImFyZ3VtZW50c1BheWxvYWQiLCJyZXN1bHQiLCJ0b29scyIsInRvb2wiLCJmdW5jIiwicmVzcG9uc2VJbmRleCIsInRvb2xfY2FsbF9pZCIsImZ1bmN0aW9uX25hbWUiLCJ0b29sX2NhbGxfcmVzdWx0IiwiZSIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiU1RSRUFNQUJMRV9WQUxVRV9UWVBFIiwiZm9yIiwiREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUiLCJjcmVhdGVTdHJlYW1hYmxlVUkiLCJjdXJyZW50VmFsdWUiLCJjbG9zZWQiLCJhc3NlcnRTdHJlYW0iLCJtZXRob2QiLCJ3YXJuaW5nVGltZW91dCIsIndhcm5VbmNsb3NlZFN0cmVhbSIsInByb2Nlc3MiLCJjbGVhclRpbWVvdXQiLCJyZXNvbHZhYmxlIiwiU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLIiwiY3JlYXRlU3RyZWFtYWJsZVZhbHVlIiwiaXNSZWFkYWJsZVN0cmVhbSIsImxvY2tlZCIsImNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGwiLCJzdHJlYW1hYmxlVmFsdWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UHJvbWlzZSIsImN1cnJlbnRQYXRjaFZhbHVlIiwiY3JlYXRlV3JhcHBlZCIsImluaXRpYWxDaHVuayIsImluaXQiLCJjdXJyIiwidXBkYXRlVmFsdWVTdGF0ZXMiLCJyZXNvbHZlUHJldmlvdXMiLCJyZW5kZXIiLCJ1aSIsImluaXRpYWwiLCJmdW5jdGlvbnMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZGVzY3JpcHRpb24iLCJwYXJhbWV0ZXJzIiwiZmluaXNoZWQiLCJoYW5kbGVSZW5kZXIiLCJyZW5kZXJlciIsInRoZW4iLCJub2RlIiwiaXRlcmF0b3IiLCJoYXNGdW5jdGlvbiIsInByb3ZpZGVyIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwiZnVuY3Rpb25DYWxsUGF5bG9hZCIsInRvb2xDYWxsUGF5bG9hZCIsIkludmFsaWRUb29sQXJndW1lbnRzRXJyb3IiLCJOb1N1Y2hUb29sRXJyb3IiLCJzYWZlUGFyc2VKU09OIiwiZGVmYXVsdFRleHRSZW5kZXJlciIsInN0cmVhbVVJIiwiYWJvcnRTaWduYWwiLCJzZXR0aW5ncyIsInRleHRSZW5kZXIiLCJyZXRyeSIsInZhbGlkYXRlZFByb21wdCIsImRvU3RyZWFtIiwibW9kZSIsImlucHV0Rm9ybWF0IiwiZm9ya2VkU3RyZWFtIiwidGVlIiwiaGFzVG9vbENhbGwiLCJ0ZXh0RGVsdGEiLCJhdmFpbGFibGVUb29scyIsImtleXMiLCJwYXJzZVJlc3VsdCIsInNjaGVtYSIsInN1Y2Nlc3MiLCJ0b29sQXJncyIsImdlbmVyYXRlIiwiUmVhY3QiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJpbm5lckFjdGlvbiIsImFjdGlvbiIsIndyYXBBY3Rpb24iLCJiaW5kIiwiY3JlYXRlQUkiLCJhY3Rpb25zIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsVUlTdGF0ZSIsIm9uR2V0VUlTdGF0ZSIsIndyYXBwZWRBY3Rpb25zIiwid3JhcHBlZFN5bmNVSVN0YXRlIiwiQUkiLCJwcm9wcyIsInVpU3RhdGUiLCJhaVN0YXRlIiwiYWlTdGF0ZURlbHRhIiwibmV3QUlTdGF0ZURlbHRhIiwibmV3VUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlUGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/izayahhudnut/Documents/DOR-15/Budtenders/GreenestBudtender2.0/frontend/node_modules/ai/rsc/dist/rsc-shared.mjs#useUIState`);


/***/ })

};
;